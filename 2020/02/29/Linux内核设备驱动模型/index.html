<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Code controls all the hardware"><title>Linux内核设备驱动模型 | Evil Code</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux内核设备驱动模型</h1><a id="logo" href="/.">Evil Code</a><p class="description">Coding Change The World</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux内核设备驱动模型</h1><div class="post-meta">Feb 29, 2020<span> | </span><span class="category"><a href="/categories/Kernel/">Kernel</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#设备驱动模型概述"><span class="toc-number">1.</span> <span class="toc-text">设备驱动模型概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#核心数据结构Kobject"><span class="toc-number">2.</span> <span class="toc-text">核心数据结构Kobject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sysfs文件系统"><span class="toc-number">3.</span> <span class="toc-text">sysfs文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设备驱动模型组件"><span class="toc-number">4.</span> <span class="toc-text">设备驱动模型组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Devices"><span class="toc-number">4.1.</span> <span class="toc-text">Devices</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Drivers"><span class="toc-number">4.2.</span> <span class="toc-text">Drivers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buses"><span class="toc-number">4.3.</span> <span class="toc-text">Buses</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#总线的注册"><span class="toc-number">4.3.1.</span> <span class="toc-text">总线的注册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向总线添加设备（device）"><span class="toc-number">4.3.2.</span> <span class="toc-text">向总线添加设备（device）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向总线添加驱动（device-driver"><span class="toc-number">4.3.3.</span> <span class="toc-text">向总线添加驱动（device_driver)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设备和驱动的绑定"><span class="toc-number">4.3.4.</span> <span class="toc-text">设备和驱动的绑定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Classes"><span class="toc-number">4.4.</span> <span class="toc-text">Classes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建和注册"><span class="toc-number">4.4.1.</span> <span class="toc-text">创建和注册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向class添加设备"><span class="toc-number">4.4.2.</span> <span class="toc-text">向class添加设备</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dev下设备文件的创建"><span class="toc-number">5.</span> <span class="toc-text">/dev下设备文件的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核uevent向用户空间的通知"><span class="toc-number">6.</span> <span class="toc-text">内核uevent向用户空间的通知</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内核发送事件"><span class="toc-number">6.1.</span> <span class="toc-text">内核发送事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户空间处理事件"><span class="toc-number">6.2.</span> <span class="toc-text">用户空间处理事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设备驱动模型应用实例"><span class="toc-number">7.</span> <span class="toc-text">设备驱动模型应用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实例说明"><span class="toc-number">7.1.</span> <span class="toc-text">实例说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例代码"><span class="toc-number">7.2.</span> <span class="toc-text">实例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例测试"><span class="toc-number">7.3.</span> <span class="toc-text">实例测试</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="设备驱动模型概述"><a href="#设备驱动模型概述" class="headerlink" title="设备驱动模型概述"></a>设备驱动模型概述</h2><p>早期linux内核为设备驱动开发者提供了很少的基本功能接口：申请动态内存，保留I/O地址范围等。早期的硬件设备编程困难，即使属于同一总线上的两个不同硬件设备之间也很少有共性。因此，需要为设备驱动开发者设计一个通用的模型。现如今，情况不一样了。总线类型规范了硬件设备的内部设计，导致如今的即使是不同类型的设备都支持相似的功能，针对这样的设备的设备驱动应该关心以下实现：电源管理，即插即用和热插拔。系统中每一个硬件设备的电源都由内核来管理。比如一个电池供电的电脑进入“standby”模式，内核必须强制每一个硬件设备为低电状态。因此，每一个可以设定为”standby“状态的设备的驱动必须包含一个可以将硬件设备设定为低电状态的回调函数。同时硬件设备也要按照精确的顺序设定为”standby“状态，否则有些硬件设备可能进入错误的电源状态，例如，linux内核必须先将硬盘设定为”standby“状态，然后才是硬盘控制器，如果该顺序反了，硬盘控制器将不能给硬盘发送命令。为了实现该类的操作，Linux2.6提供了一些数据结构和函数接口，这些数据结构和接口为系统中所有的总线，设备和设备驱动提供了统一的操作方法。这个框架就叫做设备驱动模型。</p>
<h2 id="核心数据结构Kobject"><a href="#核心数据结构Kobject" class="headerlink" title="核心数据结构Kobject"></a>核心数据结构Kobject</h2><p>kobject是设备驱动模型的核心数据结构。它被固有的绑定在sysfs文件系统中：每一个kobject相当于sysfs中的一个目录。kobject通常被嵌入到更大的对象中用来描述设备驱动模型的组件，因此这样的对象称作”容器“，总线，设备和设备驱动都是典型的容器。在容器中嵌入一个kobject使得内核能够：</p>
<ul>
<li>为容器维护一个引用计数</li>
<li>为容器维护一个层级结构列表或集合</li>
<li>为容器的属性提供一个用户模式下的视图</li>
</ul>
<p>Kobject在内核中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		*<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span>		*<span class="title">kset</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>	*<span class="title">ktype</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysfs_dirent</span>	*<span class="title">sd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span>		<span class="title">kref</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>; <span class="comment">/*kobject初始化状态，初始化后值为1*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;<span class="comment">/*在sysfs下创建目录的标记，创建后值为1*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;<span class="comment">/*记录kobject_uevent添加事件*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;<span class="comment">/*记录kobject_uevent移除事件，和state_add_uevent_sent用于在释放kobject的时候确定是否已经添加并且未移除，未移除则先移除*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>;<span class="comment">/*事件策略标记，不为0则不发送事件*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>name属性定义了该kobject的名字。</li>
<li>entry是用来将kobject链入kset中的链表元素。</li>
<li>parent是指向其父节点的指针，用来支持层级结构。一般指向其kset容器中的kobj对象。</li>
<li>ktype是该对象的类型，即包含该kobject的容器的类型。ktype在内核中的定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> (*release)(struct kobject *kobj);</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *(*<span class="title">child_ns_type</span>)(<span class="title">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>);</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">namespace</span>)(struct kobject *kobj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，release回调函数在释放kobject本身的时候被调用。sysfs_ops是sysfs的操作函数表，default_attrs是该sysfs的默认属性。</p>
<ul>
<li><p>sd属性表示该kobject对象的sysfs层级别构的构建块。</p>
</li>
<li><p>kref是该对象的引用计数，也就是包含该kobject的容器的引用计数。通过kobject_get和kobject_put函数增加和减少该计数器的值，当kref计数器的值为0时，调用kobj_type结构中的release回调函数，该函数通常实现为用来释放该kobject所属的容器（仅当容器本身为动态创建时）。</p>
</li>
<li><p>kset是该kobject的组，即kset是同一类型kobject的集合（也可以不属于同一类型）。同时，kset本身又包含自己的kobject对象。kset具有以下功能：</p>
<ol>
<li>kset是一组kobject对象的容器，内核可以通过kset来跟踪设备和设备驱动</li>
<li>kset也是sysfs中的一个子目录，该目录显示了所有关联到的kobject。每个kset都包含一个kobject对象，该对象可以被设置为其它关联到的kobject的父节点。sysfs层级结构的顶层目录就是这样设计的。</li>
<li>kset支持kobject的热插拔，并且影响uevent事件向用户空间报告的方式。</li>
</ol>
<p>kset结构在内核中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>list是该集合中kobject的链表头。list_lock是kset中kobject链表头操作的保护自旋锁。kobj是kset对象本身的kobject元素。uevent_ops是该kset的uevent操作函数表，kset_uevent_ops在内核中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (* <span class="keyword">const</span> filter)(struct kset *kset, struct kobject *kobj);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *(* <span class="keyword">const</span> name)(struct kset *kset, struct kobject *kobj);</span><br><span class="line">	<span class="keyword">int</span> (* <span class="keyword">const</span> uevent)(struct kset *kset, struct kobject *kobj,</span><br><span class="line">		      struct kobj_uevent_env *env);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，filter函数用来决定某个uevent是否被发送到特定kobject的用户空间，该函数返回0表示uevent不会被发送。name函数用来覆盖uevent发送到用户空间的kset的默认名称。uevent函数在uevent要发送到用户空间以运行更多的环境变量添加到uevent时调用。</p>
</li>
</ul>
<p><strong>总结：kobject通常作为一个对象直接嵌入到其它类型的数据结构中，嵌入kobject的对象称作容器，ktype表示kobject的类型，也表示容器的类型，ktype提供了该类kobject的release方法和sysfs操作方法。kset是kobject的容器，kobject通过list_head链表元素链接在kset的list头节点上，一般来说一个kset中的kobject是同一类型的，即共享同一个ktype。注册到设备驱动模型中的所有kobject和kset对象的层级关系都在sysfs中呈现。</strong></p>
<p>kobject和kset的初始化和添加接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*kobject初始化函数*/</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">kobject_init</span><span class="params">(struct kobject *kobj, struct kobj_type *ktype)</span></span>;</span><br><span class="line"><span class="comment">/*kobject注册函数*/</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">kobject_add</span><span class="params">(struct kobject *kobj, struct kobject *parent, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="comment">/*kobject初始化并注册函数*/</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">kobject_init_and_add</span><span class="params">(struct kobject *kobj, struct kobj_type 	*ktype, struct kobject *parent, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="comment">/*注册或移除kobject后发送事件函数，action为KOBJ_ADD或者KOBJ_REMOVE*/</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">kobject_uevent</span><span class="params">(struct kobject *kobj, <span class="keyword">enum</span> kobject_action action)</span></span>;</span><br><span class="line"><span class="comment">/*kset创建和注册函数，kset只动态创建*/</span></span><br><span class="line"> <span class="function">struct kset *<span class="title">kset_create_and_add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, struct kset_uevent_ops *u,</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct kobject *parent)</span></span>;</span><br><span class="line"><span class="comment">/*kset销毁函数*/</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">kset_unregister</span><span class="params">(struct kset *kset)</span></span>;</span><br></pre></td></tr></table></figure>
<p>kobject和kset使用实例，参考linux内核源码：samples/kobject/kset-example.c和samples/kobject/kobject-example.c</p>
<h2 id="sysfs文件系统"><a href="#sysfs文件系统" class="headerlink" title="sysfs文件系统"></a>sysfs文件系统</h2><p>sysfs是一个给用户层提供设备驱动模型中所有对象的层级关系视图的文件系统，它被挂载的路径是/sys/目录，存在于/sys/目录下的每一个子目录都是一个kset对象(这里说的对象是kobject的容器)或者kobject关联到sysfs的目录。/sys/目录下存在以下目录（kset对象/kobject）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">block     class     devices   fs        module</span><br><span class="line">bus       dev       firmware  kernel    power</span><br></pre></td></tr></table></figure>
<p>这些目录有的是通过kset_create_and_add接口注册到sysfs上的kset对象，比如class，devices，module，bus，以bus目录为例，在内核中该目录的注册代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bus_kset = kset_create_and_add(<span class="string">"bus"</span>, &amp;bus_uevent_ops, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!bus_kset)</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br></pre></td></tr></table></figure>
<p>有的是通过kobject_create_and_add接口注册到sysfs上的kobject对象，比如fs，目录，其注册代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs_kobj = kobject_create_and_add(<span class="string">"fs"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!fs_kobj)</span><br><span class="line">	printk(KERN_WARNING <span class="string">"%s: kobj create error\n"</span>, __func__);</span><br></pre></td></tr></table></figure>
<p>目录说明：</p>
<p><strong>block</strong>（kobject）：存放的是所有的块设备对象（kobject）的链接文件，这些块设备源文件在devices目录中。</p>
<p><strong>class</strong>(kset)：存放的是所有注册到设备驱动模型中的class对象，由于class是device容器，所以在每一个/sys/class目录的子目录中，存放的是该class包含的所以device对象的链接文件。</p>
<p><strong>devices</strong>(kset)：存放的是所有设备驱动模型中的device对象，device对象是层级结构的，每一个device对象关联的/sys/devices/中的目录中，每一个文件是该device对象的属性文件，每一个目录是该device子设备对象，即每一个device对象是所有其关联的sysfs目录的所有子目录对应的device对象的父设备对象。</p>
<p><strong>fs</strong>(kobject)：是文件系统基础对象，其子目录是具体文件系统的kset对象。每个文件系统的目录中存放的是其特有对象目录。</p>
<p><strong>module</strong>(kset)：存放的是所有有参数的module对象，这些对象一般包含一个parameters对象和一些属性文件。parameters目录中的每一个文件都表示模块的一个参数。</p>
<p><strong>bus</strong>(kset)：存放的是所有的总线的kset对象，每一个总线kset对象又包含一些属性文件和两个kset对象，分别是devices和drivers，分别表示注册打扫该总线上的设备和驱动列表。由于所有的设备都已经在/sys/devices目录中了，所以devices对象中的子设备对象都是相应的/sys/devices中的对象的链接。</p>
<p><strong>dev</strong>(kobject)：该目录为一个kobject，里面包含两个kobject对象，一个名为char，一个名为block。char目录中存放的是以【主设备号:此设备号】命名的字符设备的对象的链接目录文件，和char对象类似，block对象目录存放以主次设备号命名的块设备的对象的链接文件，它们都指向了/sys/devices中的设备对象。</p>
<p><strong>firmware</strong>(kobject)：存放固件相关的对象，比如设备树对象和设备树属性文件等。</p>
<p><strong>kernel</strong>(kobject)：存放内核中可调整参数属性文件和kobject对象或kset对象。</p>
<p><strong>power</strong>(kobject)：power对象存放的是电源管理子系统相关属性文件。</p>
<h2 id="设备驱动模型组件"><a href="#设备驱动模型组件" class="headerlink" title="设备驱动模型组件"></a>设备驱动模型组件</h2><p>设备驱动模型由一些表示总线，设备和设备驱动等的基础数据结构组成。</p>
<h3 id="Devices"><a href="#Devices" class="headerlink" title="Devices"></a>Devices</h3><p>设备驱动模型中的每一个设备用一个device对象表示，设备通常用来描述硬件信息。device对象在内核中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_private</span>	*<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*init_name; <span class="comment">/* initial name of the device */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> *<span class="title">type</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">mutex</span>;</span>	<span class="comment">/* mutex to synchronize calls to</span></span><br><span class="line"><span class="comment">					 * its driver.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span>	*<span class="title">bus</span>;</span>		<span class="comment">/* type of bus device is on */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span>	<span class="comment">/* which driver has allocated this</span></span><br><span class="line"><span class="comment">					   device */</span></span><br><span class="line">	<span class="keyword">void</span>		*platform_data;	<span class="comment">/* Platform specific data, device</span></span><br><span class="line"><span class="comment">					   core doesn't touch it */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_info</span>	<span class="title">power</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_domain</span>	*<span class="title">pm_domain</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">int</span>		numa_node;	<span class="comment">/* NUMA node this device is close to */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	u64		*dma_mask;	<span class="comment">/* dma mask (if dma'able device) */</span></span><br><span class="line">	u64		coherent_dma_mask;<span class="comment">/* Like dma_mask, but for</span></span><br><span class="line"><span class="comment">					     alloc_coherent mappings as</span></span><br><span class="line"><span class="comment">					     not all hardware supports</span></span><br><span class="line"><span class="comment">					     64 bit addresses for consistent</span></span><br><span class="line"><span class="comment">					     allocations such descriptors. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_dma_parameters</span> *<span class="title">dma_parms</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">dma_pools</span>;</span>	<span class="comment">/* dma pools (if dma'ble) */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_coherent_mem</span>	*<span class="title">dma_mem</span>;</span> <span class="comment">/* internal for coherent mem</span></span><br><span class="line"><span class="comment">					     override */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cma</span> *<span class="title">cma_area</span>;</span>		<span class="comment">/* contiguous memory area for dma</span></span><br><span class="line"><span class="comment">					   allocations */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* arch specific additions */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span>	<span class="title">archdata</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">of_node</span>;</span> <span class="comment">/* associated device tree node */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">dev_t</span>			devt;	<span class="comment">/* dev_t, creates the sysfs "dev" */</span></span><br><span class="line">	u32			id;	<span class="comment">/* device instance */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">spinlock_t</span>		devres_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">devres_head</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span>	<span class="title">knode_class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">class</span>		*<span class="title">class</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span>	<span class="comment">/* optional groups */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>	(*release)(struct device *dev);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>device关联的sysfs的目录是/sys/devices。device也是层级结构的，device的parent成员指向其父亲节点，同时，该device又可能是其它节点的父节点。kobj成员是该对象的kobject对象，主要用来维护其计数器，通过get_device和put_device接口增加和减少设备计数。bus成员是该device所属总线的指针。driver成员指针指向该device关联的驱动结构。class指针指向该device所属的class。devres_head成员是其资源链表头，用来管理自己的资源。release函数在释放该device时调用。type指针指向一个device_type结构类型，用来描述该device的类型。该结构主要实现了一组操作函数，即通过操作分类。of_node成员是该设备的设备树节点。p成员指向一个device_private结构，用来描述该设备的驱动数据的核心部分信息。该结构在内核中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_private</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_children</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_driver</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_bus</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">deferred_probe</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *driver_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中klist_children是该device的说有子节点的头节点。knode_parent是同级别列表中的节点。knode_driver是驱动列表中的节点。knode_bus表示其在bus的设备链表中的节点。deferred_probe是链入deferred_probe_list的链表元素，deferred_probe_list主要用来做因为某些资源不可得或依赖其它驱动先probe等原因需要延迟的probe操作。drvier_data是驱动特殊数据。device指向该device_private自身所属的device。</p>
<p>device注册接口为device_register，取消注册接口为device_unreigster。</p>
<p>device的注册分两个步骤，首先是调用device_initialize初始化device的kobj成员以及其它一些固有成员，接着调用device_add接口添加device。device_add函数主要依次完成了以下 操作:</p>
<p>申请和初始化其device_private结构成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dev-&gt;p) &#123;</span><br><span class="line">		error = device_private_init(dev);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用kobject_add添加kobject：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> Error;</span><br></pre></td></tr></table></figure>
<p>kobject_add同时会在sys目录下或者sys目录的子目录下（取决于parent）创建其目录。</p>
<p>调用device_create_file在sys目录中对应的目录下创建uevent文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error = device_create_file(dev, &amp;uevent_attr);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line">	<span class="keyword">goto</span> attrError;</span><br></pre></td></tr></table></figure>
<p>如果该设备有设备号，则在其关联的目录下创建dev文件，用来获取该设备的主次设备号，并且在/sys/class目录下(如果设备有class对象)或者/sys/dev/目录下为其创建链接，并在devtmpfs中创建设备节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MAJOR(dev-&gt;devt)) &#123;</span><br><span class="line">		error = device_create_file(dev, &amp;devt_attr);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> ueventattrError;</span><br><span class="line"></span><br><span class="line">		error = device_create_sys_dev_entry(dev);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> devtattrError;</span><br><span class="line"></span><br><span class="line">		devtmpfs_create_node(dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的代码片段可知，在系统中不但可以使用mdev通过扫描/sys/class来在/dev/下创建设备节点，也可以通过挂载devtmpfs到/dev/目录下实现设备节点可见。在系统中可以通过下面的命令挂载devtmpfs：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t devtmpfs none /dev</span><br></pre></td></tr></table></figure>
<p>接着通过device_add_class_symlinks接口在/sys/class/xxx下创建符号链接文件。（只有关联到某个已经创建的class的设备才会在class关联到的/sys/class/目录下创建链接文件，在该接口中如果判断dev-&gt;class为空立即返回）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error = device_add_class_symlinks(dev);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line">	<span class="keyword">goto</span> SymlinkError;</span><br></pre></td></tr></table></figure>
<p>接着调用device_add_attrs在/sys/devices下相关的目录中创建其属性文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error = device_add_attrs(dev);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line">	<span class="keyword">goto</span> AttrsError;</span><br></pre></td></tr></table></figure>
<p>接着调用bus_add_device将该dev添加到dev所属bus的设备链表上。同时，为该dev在/sys/bus/目录中其相关bus中创建符号链接文件，并且在该dev对应的sys/devices/目录中创建名为subsystem的符号链接目录，subsystem是来自该设备所属总线的subsys中的kset成员，该过程见Buses章节中向总线添加设备一节的描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error = bus_add_device(dev);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line">	<span class="keyword">goto</span> BusError;</span><br></pre></td></tr></table></figure>
<p>接着调用dpm_sysfs_add接口在sys/devices下该设备的目录中添加power目录以及在power目录中添加一些属性文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error = dpm_sysfs_add(dev);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line">	<span class="keyword">goto</span> DPMError;</span><br></pre></td></tr></table></figure>
<p>接着向总线通知链发送总线添加设备通知，在向用户空间发送kobj添加事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Notify clients of device addition.  This call must come</span></span><br><span class="line"><span class="comment">* after dpm_sysfs_add() and before kobject_uevent().</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">	blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">					 BUS_NOTIFY_ADD_DEVICE, dev);</span><br><span class="line"></span><br><span class="line">kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);</span><br></pre></td></tr></table></figure>
<p>接着调用bus_probe_device，在该函数中判断总线是否设置了drivers_autoprobe，如果设置了，则调用device_attach函数来和对应的驱动进行绑定，device_attach实现过程见Buses章节的<a herf="#设备和驱动的绑定">设备和驱动的绑定</a>一节。绑定驱动之后再调用所有注册到总线的subsys_interface的add_dev回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bus_probe_device(dev);</span><br></pre></td></tr></table></figure>
<p>然后如果该设备有父设备，在将该设备链接到父设备的子设备链表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parent)</span><br><span class="line">	klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,</span><br><span class="line">		       &amp;parent-&gt;p-&gt;klist_children);</span><br></pre></td></tr></table></figure>
<p>最后判断如果该设备属于某个class，则将该设备添加到其所属class的设备链表上，并将该添加事件通知到class上的所有interface 上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dev-&gt;class) &#123;</span><br><span class="line">	mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">	<span class="comment">/* tie the class to the device */</span></span><br><span class="line">	klist_add_tail(&amp;dev-&gt;knode_class,</span><br><span class="line">			      &amp;dev-&gt;class-&gt;p-&gt;klist_devices);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* notify any interfaces that the device is here */</span></span><br><span class="line">	list_for_each_entry(class_intf,</span><br><span class="line">				   &amp;dev-&gt;class-&gt;p-&gt;interfaces, node)</span><br><span class="line">		<span class="keyword">if</span> (class_intf-&gt;add_dev)</span><br><span class="line">			class_intf-&gt;add_dev(dev, class_intf);</span><br><span class="line">	mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，device向内核设备驱动模型的添加结束。主要建立了设备和sysfs的关联，和驱动的绑定，和总线的关联以及和devtmpfs的关联等。device的取消注册接口device_unreigster的过程和注册接口的相反，依次取消关联和删除设备。</p>
<h3 id="Drivers"><a href="#Drivers" class="headerlink" title="Drivers"></a>Drivers</h3><p>在设备驱动模型中，驱动通常提供设备的操作方法，即设备能力的代码实现。驱动在内核中用device_driver结构体来描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span>		*<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*mod_name;	<span class="comment">/* used for built-in modules */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> suppress_bind_attrs;	<span class="comment">/* disables bind/unbind via sysfs */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span>	*<span class="title">of_match_table</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*probe) (struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*remove) (struct device *dev);</span><br><span class="line">	<span class="keyword">void</span> (*shutdown) (struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*suspend) (struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">	<span class="keyword">int</span> (*resume) (struct device *dev);</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，bus成员指向该驱动所属的总线，of_match_table成员主要用来和设备中的of_node节点做匹配。其中的回调函数主要用来实现热插拔，即插即用，以及电源管理相关的功能。probe函数在总线通过设备匹配到驱动或通过驱动匹配到设备的时候调用。remove函数在关联的设备移除的时候或者驱动本身退出的时候调用以取消关联。shutdown函数在关机的时候调用以停止关联的设备。suspend用来使设备进入睡眠模式，低电模式。resume函数用来将设备从睡眠模式唤醒。pm指针成员指向匹配到的设备的电源管理操作集。p指针指向该驱动核心的私有数据，该成员的类型定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_bus</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module_kobject</span> *<span class="title">mkobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，kobj是该driver的kobject对象，主要用来维护所属驱动的使用计数，通过get_driver和put_driver函数来增加或减少计数。klist_devices是该driver关联的设备的链表头，一般在总线匹配到设备的时候将设备加如该链表。knode_bus是driver加入总线上驱动链表的链表元素。mkobj指向驱动所属module_kobject，module_kobject用来关联/sys/module中的对象。driver指针指向该driver_pribate结构所属的device_driver对象。</p>
<p>和device对象一样，device_driver对象通常静态嵌入在更大的容器对象中，比如platform_driver对象的driver成员就是一个device_driver结构。</p>
<p>device_driver的注册接口是driver_register，该接口用来向内核设备驱动模型中添加一个device_driver对象，并为其在sysfs中创建关联。</p>
<p>driver_register函数分析：</p>
<p>driver_register中首先通过driver_find函数在总线上根据其name属性查找该driver，如果找到则返回，不再添加，防止其重复添加。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">other = driver_find(drv-&gt;name, drv-&gt;bus);</span><br><span class="line"><span class="keyword">if</span> (other) &#123;</span><br><span class="line">	printk(KERN_ERR <span class="string">"Error: Driver '%s' is already registered, "</span></span><br><span class="line">		<span class="string">"aborting...\n"</span>, drv-&gt;name);</span><br><span class="line">	<span class="keyword">return</span> -EBUSY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着调用bus_add_driver接口将device_driver对象添加到其所属的总线上，为该device_driver绑定设备，在sysfs中创建相关对象，以及创建其与总线和设备的关联。bus_add_driver详细过程参加Buses章节的向总线添加驱动一节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = bus_add_driver(drv);</span><br><span class="line">if (ret)</span><br><span class="line">	return ret;</span><br></pre></td></tr></table></figure>
<p>最后在driver对应的sysfs目录中添加组目录，在组目录中添加组文件。至此，整个driver_register过程结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = driver_add_groups(drv, drv-&gt;groups);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">	bus_remove_driver(drv);</span><br></pre></td></tr></table></figure>
<p>driver_unregister接口和driver_register接口相反，首先driver目录中删除groups文件，然后调用bus_remove_driver接口从总线上删除driver相关文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">driver_unregister</span><span class="params">(struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!drv || !drv-&gt;p) &#123;</span><br><span class="line">		WARN(<span class="number">1</span>, <span class="string">"Unexpected driver unregister!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	driver_remove_groups(drv, drv-&gt;groups);</span><br><span class="line">	bus_remove_driver(drv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Buses"><a href="#Buses" class="headerlink" title="Buses"></a>Buses</h3><p>总线是处理器和设备之间的通道，在设备驱动模型里面，所有的设备都通过一个总线连接在一起，总线包括内部总线和虚拟总线。</p>
<p>在设备驱动模型中，kset是kobject的集合，subsystem是kset的集合，每一个总线都是一个subsystem，关联的susfs目录/sys/bus/是基础对象，所有总线（subsystem）被注册到该对象上。每一个总线subsystem中包含两个kset对象，它们关联的sysfs总线上目录名分别为devices和drivers。drivers包含了添加到该总线上的所有的device_drivers对象(kobject)，devices目录包含了所有添加到该总线上的device对象(kobject)，由于所有device对象已经注册在devices目录中，所以在总线subsystem的devices(kset)中的device对象都是其对应的/sys/devices中的链接文件。</p>
<p>在设备驱动模型中，当一个驱动要注册时，会调用到总线的驱动添加接口将驱动添加到总线，像总线添加驱动的时候会根据总线设定的规则匹配可以被该驱动处理的所有设备，并与之建立关联。当一个设备注册的时候也会调用总线添加设备的接口将设备添加到总线上，和总线创建关联，同时会在总线上遍历驱动，根据总线的匹配规则匹配到自己的驱动，并和驱动创建关联。</p>
<p>内核中总线描述符定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*dev_name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">dev_root</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bus_attribute</span>	*<span class="title">bus_attrs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span>	*<span class="title">dev_attrs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">driver_attribute</span>	*<span class="title">drv_attrs</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">	<span class="keyword">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">	<span class="keyword">int</span> (*probe)(struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*remove)(struct device *dev);</span><br><span class="line">	<span class="keyword">void</span> (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*suspend)(struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">	<span class="keyword">int</span> (*resume)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iommu_ops</span> *<span class="title">iommu_ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>name：指向该总线的名称。</p>
<p>dev_name：在子系统中枚举设备是使用的设备名指针。</p>
<p>dev_root：默认的父设备。</p>
<p>bus_attrs：默认的总线属性，在sysfs中以文件形式呈现。</p>
<p>dev_attrs：默认的设备属性，在sysfs中以文件形式呈现。</p>
<p>drv_attrs：默认的驱动属性，在sysfs中以文件形式呈现。</p>
<p>match：驱动匹配回调函数，当一个设备或驱动向总线注册时被调用，如果匹配成功返回非零值。</p>
<p>uevent：当设备添加，移除或其它生成uevents添加环境变量事件时调用。</p>
<p>probe：当一个设备或驱动添加到该总线上时，如果设备和驱动匹配成功，就会调用该回调函数，一般用来初始化设备。</p>
<p>remove：当一个设备从该总线上移除时调用，以释放设备相关的资源。</p>
<p>shutdown：在系统关机的时候调用以停止设备。</p>
<p>suspend：当总线上的设备要进入睡眠模式的时候调用。</p>
<p>resume：当要唤醒睡眠中的设备时调用。</p>
<p>pm：表示该总线上的电源管理的操作函数集。</p>
<p>iommu_ops：该总线上IOMMU特定测操作集合，用来关联某个总线上的IOMMU驱动，运行总线做一些特殊的设定操作。</p>
<p>p：subsys_private类型的总线子系统私有数据。包含总线的kset，以及设备和驱动链表等。</p>
<p>subsys_private类型在内核中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">subsys</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">devices_kset</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">interfaces</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">drivers_kset</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_drivers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">bus_notifier</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> drivers_autoprobe:<span class="number">1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">glue_dirs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">class</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>subsys：定义该子系统的kset。</p>
<p>devices_kset：该总线子系统的devices目录</p>
<p>interfaces：总线子系统上的interfaces链表。</p>
<p>mutex：用来保护devices和interfaces链表的互斥锁。</p>
<p>drivers_kset：该总线子系统的drivers目录。</p>
<p>klist_devices：devices目录中的设备的链表。</p>
<p>klist_drivers：drivers目录中的驱动的链表。</p>
<p>bus_notifier：总线上通知链头。</p>
<p>drivers_autoprobe：驱动和是否可以动态匹配的属性标记。</p>
<p>bus：指向该subsys_private结构所属的总线对象。</p>
<p>glue_dirs：放置在父设备直接的glue目录，用来避免命名空间冲突。</p>
<p>class：指向该结构关联的class对象。</p>
<h4 id="总线的注册"><a href="#总线的注册" class="headerlink" title="总线的注册"></a>总线的注册</h4><p>总线注册接口为bus_register，是一个宏函数，实际调用的接口是__bus_register函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bus_register(subsys)			\</span></span><br><span class="line">(&#123;						\</span><br><span class="line">	<span class="keyword">static</span> struct lock_class_key __key;	\</span><br><span class="line">	__bus_register(subsys, &amp;__key);	\</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在__bus_register函数中首先为要注册的总线对象申请了subsys_private对象，并初始化了总线的通知链头：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">priv = kzalloc(<span class="keyword">sizeof</span>(struct subsys_private), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!priv)</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">priv-&gt;bus = bus;</span><br><span class="line">bus-&gt;p = priv;</span><br><span class="line"></span><br><span class="line">BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</span><br></pre></td></tr></table></figure>
<p>接着初始化总线p成员的subsys（kset），并通过kset_register注册该kset对象，即在/sys/bus下创建了以该总线的名字为名称的目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, <span class="string">"%s"</span>, bus-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">priv-&gt;subsys.kobj.kset = bus_kset;</span><br><span class="line">priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;</span><br><span class="line">priv-&gt;drivers_autoprobe = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">retval = kset_register(&amp;priv-&gt;subsys);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>
<p>接着在刚创建的sysfs关联的目录下创建了uevent属性文件，同时在该目录添加了devices和drivers两个kset对象，即在该目录创建了devices和drivers两个目录。uevent文件用来控制内核向用户空间发送uevent事件，对应的向该文件写入的字符串为：“add”，“remove”，“change”，“move”， “online”， “offline”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">retval = bus_create_file(bus, &amp;bus_attr_uevent);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bus_uevent_fail;</span><br><span class="line"></span><br><span class="line">priv-&gt;devices_kset = kset_create_and_add(<span class="string">"devices"</span>, <span class="literal">NULL</span>,</span><br><span class="line">					 &amp;priv-&gt;subsys.kobj);</span><br><span class="line"><span class="keyword">if</span> (!priv-&gt;devices_kset) &#123;</span><br><span class="line">	retval = -ENOMEM;</span><br><span class="line">	<span class="keyword">goto</span> bus_devices_fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priv-&gt;drivers_kset = kset_create_and_add(<span class="string">"drivers"</span>, <span class="literal">NULL</span>,</span><br><span class="line">					 &amp;priv-&gt;subsys.kobj);</span><br><span class="line"><span class="keyword">if</span> (!priv-&gt;drivers_kset) &#123;</span><br><span class="line">	retval = -ENOMEM;</span><br><span class="line">	<span class="keyword">goto</span> bus_drivers_fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着初始化了总线p成员的interfaces链表头，mutex互斥锁，klist_devices设备链表以及klist_drivers驱动链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INIT_LIST_HEAD(&amp;priv-&gt;interfaces);</span><br><span class="line">__mutex_init(&amp;priv-&gt;mutex, <span class="string">"subsys mutex"</span>, key);</span><br><span class="line">klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class="line">klist_init(&amp;priv-&gt;klist_drivers, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>最后先向总线关联的sysfs目录中添加了drivers_probe和drivers_autoprobe属性文件，然后添加了其它总线属性文件。drivers_autoprobe属性表示设备或驱动添加的时候是否匹配并调用驱动probe函数（创建关联），该属性值为非零表示自动创建关联。drivers_probe文件权限为只写，向该文件写入设备名称，则内核开始在总线上找到该设备，并为其和总线上的驱动创建关联。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">retval = add_probe_files(bus);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bus_probe_files_fail;</span><br><span class="line"></span><br><span class="line">retval = bus_add_attrs(bus);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bus_attrs_fail;</span><br></pre></td></tr></table></figure>
<p>至此，完成了整个总线基础部分的注册以及其和sysfs的关联。</p>
<h4 id="向总线添加设备（device）"><a href="#向总线添加设备（device）" class="headerlink" title="向总线添加设备（device）"></a>向总线添加设备（device）</h4><p>向总线添加设备的接口为bus_add_device函数，该函数首先从设备中获取到设备设定的所属总线：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span> = <span class="title">bus_get</span>(<span class="title">dev</span>-&gt;<span class="title">bus</span>);</span></span><br></pre></td></tr></table></figure>
<p>接着向设备中添加总线上设定的设备属性文件，即在设备关联的sysfs目录中添加总线上设定的设备属性文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error = device_add_attrs(bus, dev);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line">	<span class="keyword">goto</span> out_put;</span><br></pre></td></tr></table></figure>
<p>再接着在总线的devices目录中为设备所属sysfs目录创建链接文件，同时在设备所属sysfs目录中创建名为subsystem的链接文件，subsystem链接文件指向总线在sysfs中所属的目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error = sysfs_create_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj,</span><br><span class="line">				&amp;dev-&gt;kobj, dev_name(dev));</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line">	<span class="keyword">goto</span> out_id;</span><br><span class="line">error = sysfs_create_link(&amp;dev-&gt;kobj,</span><br><span class="line">		&amp;dev-&gt;bus-&gt;p-&gt;subsys.kobj, <span class="string">"subsystem"</span>);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line">	<span class="keyword">goto</span> out_subsys;</span><br></pre></td></tr></table></figure>
<p>最后通过设备的p成员的knode_bus（klist链表成员）将该设备添加到总线的klist_devices链表上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices);</span><br></pre></td></tr></table></figure>
<p>至此完成设备和总线的关联以及设备所属sysfs中的目录和总线所属sysfs中的目录的关联。</p>
<h4 id="向总线添加驱动（device-driver"><a href="#向总线添加驱动（device-driver" class="headerlink" title="向总线添加驱动（device_driver)"></a>向总线添加驱动（device_driver)</h4><p>向总线添加驱动的接口为bus_add_driver函数，该函数先从要添加驱动中获得驱动设定的总线：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bus = bus_get(drv-&gt;bus);</span><br><span class="line"><span class="keyword">if</span> (!bus)</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure>
<p>接着为该驱动申请driver_private对象，并初始化其设备链表头，初始化其kset为总线的驱动kset对象，即要注册的驱动对象在sysfs下的父目录是sysfs中总线目录的drivers目录（/sys/bus/xxx/drivers）然后在该目录中创建该驱动对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">priv = kzalloc(<span class="keyword">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!priv) &#123;</span><br><span class="line">	error = -ENOMEM;</span><br><span class="line">	<span class="keyword">goto</span> out_put_bus;</span><br><span class="line">&#125;</span><br><span class="line">klist_init(&amp;priv-&gt;klist_devices, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">priv-&gt;driver = drv;</span><br><span class="line">drv-&gt;p = priv;</span><br><span class="line">priv-&gt;kobj.kset = bus-&gt;p-&gt;drivers_kset;</span><br><span class="line">error = kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, <span class="literal">NULL</span>,</span><br><span class="line">			     <span class="string">"%s"</span>, drv-&gt;name);</span><br></pre></td></tr></table></figure>
<p>接着判断总线的drivers_autoprobe属性，如果该属性值不为零，则调用driver_attach函数将驱动和匹配到的设备<a herf="#设备和驱动的绑定">绑定</a>，绑定成功后将该驱动添加到总线的驱动链表上。同时将该驱动和module_kset创建关联，即在该驱动关联的sysfs的目录中创建名为module的链接文件，指向该驱动所属module在/sys/module目录中的对象，并在module所属的sysfs目录中创建drivers目录，同时在该module目录的drivers目录中创建正在添加的device_driver对象的链接文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) &#123;</span><br><span class="line">	error = driver_attach(drv);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> out_unregister;</span><br><span class="line">&#125;</span><br><span class="line">klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);</span><br><span class="line">module_add_driver(drv-&gt;owner, drv);</span><br></pre></td></tr></table></figure>
<p>接着在该device_driver所属的sysfs目录中添加uevent文件，添加总线上指定的属性文件，如果没有设置该驱动的suppress_bind_attrs标记，则同时在该目录中添加bind和ubind文件。uevent属性文件用来控制内核向用户空间发送kobject事件。bind和ubind属性文件用来控制内核让驱动绑定或解除绑定写入bind或ubind文件的设备名表示的设备：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">error = driver_create_file(drv, &amp;driver_attr_uevent);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">	printk(KERN_ERR <span class="string">"%s: uevent attr (%s) failed\n"</span>,</span><br><span class="line">		__func__, drv-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line">error = driver_add_attrs(bus, drv);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">	<span class="comment">/* How the hell do we get out of this pickle? Give up */</span></span><br><span class="line">	printk(KERN_ERR <span class="string">"%s: driver_add_attrs(%s) failed\n"</span>,</span><br><span class="line">		__func__, drv-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!drv-&gt;suppress_bind_attrs) &#123;</span><br><span class="line">	error = add_bind_files(drv);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		<span class="comment">/* Ditto */</span></span><br><span class="line">		printk(KERN_ERR <span class="string">"%s: add_bind_files(%s) failed\n"</span>,</span><br><span class="line">			__func__, drv-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用kobject_uevent函数向用户空间发送kobject的添加事件，完成驱动向总线的添加过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kobject_uevent(&amp;priv-&gt;kobj, KOBJ_ADD);</span><br></pre></td></tr></table></figure>
<h4 id="设备和驱动的绑定"><a href="#设备和驱动的绑定" class="headerlink" title="设备和驱动的绑定"></a>设备和驱动的绑定</h4><p>device和device_driver在注册过程中通过driver_attach和device_attach函数来互相创建绑定关系，首先看driver_attach函数（驱动绑定设备），该函数遍历总线上的所有设备，为所有设备指向__driver_attach函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int driver_attach(struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">	return bus_for_each_dev(drv-&gt;bus, NULL, drv, __driver_attach);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在__driver_attach函数中首先调用driver_match_device函数为驱动匹配设备，其实就是调用总线的match回调函数，如果匹配成功则调用driver_probe_device函数为设备和驱动建立绑定关系：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!driver_match_device(drv, dev))</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;parent)	<span class="comment">/* Needed for USB */</span></span><br><span class="line">	device_lock(dev-&gt;parent);</span><br><span class="line">device_lock(dev);</span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;driver)</span><br><span class="line">	driver_probe_device(drv, dev);</span><br><span class="line">device_unlock(dev);</span><br></pre></td></tr></table></figure>
<p>再看device_attach函数（设备绑定驱动），该函数先是判断是否该设备已经关联了驱动，如果关联的驱动则判断是否已经和该关联驱动建立绑定关系，如果没有则调用device_bind_driver函数和该关联的驱动建立绑定关系。如果没有关联任何驱动，则遍历设备所属总线上的所有驱动，为其执行__device_attach函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dev-&gt;driver) &#123;</span><br><span class="line">	<span class="keyword">if</span> (klist_node_attached(&amp;dev-&gt;p-&gt;knode_driver)) &#123;</span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = device_bind_driver(dev);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		dev-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	pm_runtime_get_noresume(dev);</span><br><span class="line">	ret = bus_for_each_drv(dev-&gt;bus, <span class="literal">NULL</span>, dev, __device_attach);</span><br><span class="line">	pm_runtime_put_sync(dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再__device_attach函数中，同样首先通过driver_match_device函数调用总线上的match函数和驱动做匹配，如果匹配成功则调用driver_probe_device函数绑定设备和驱动：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __device_attach(struct device_driver *drv, <span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> = <span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!driver_match_device(drv, dev))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> driver_probe_device(drv, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设备和驱动都最终通过driver_probe_device函数来和彼此建立绑定关系，下面看看该函数的实现。</p>
<p>在driver_probe_device函数中，通过调用really_probe函数使设备和驱动建立绑定：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = really_probe(dev, drv);</span><br></pre></td></tr></table></figure>
<p>在really_probe函数中，首先让device的driver指针指向要绑定的device_driver对象。并通过driver_sysfs_add函数发送驱动绑定的通知到所有注册到其所属总线上的通知块，在驱动所属的sysfs目录中创建设备sysfs目录的链接文件，在设备所属的sysfs目录中创建名sysfs目录的链接文件，名字为driver：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dev-&gt;driver = drv;</span><br><span class="line"><span class="keyword">if</span> (driver_sysfs_add(dev)) &#123;</span><br><span class="line">	printk(KERN_ERR <span class="string">"%s: driver_sysfs_add(%s) failed\n"</span>,</span><br><span class="line">		__func__, dev_name(dev));</span><br><span class="line">	<span class="keyword">goto</span> probe_failed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着调用probe回调函数，如果设置了总线的probe回调函数，则调用总线的probe函数，否则调用驱动的probe回调函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dev-&gt;bus-&gt;probe) &#123;</span><br><span class="line">	ret = dev-&gt;bus-&gt;probe(dev);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> probe_failed;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;probe) &#123;</span><br><span class="line">	ret = drv-&gt;probe(dev);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> probe_failed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用driver_bound函数完成设备和驱动的绑定以及其对应sysfs中对象的关联。在driver_bound函数首先将设备添加到驱动的设备链表头中，接着将所有延迟probe列表中的该设备删除，最后向所有注册到总线上的通知块发送绑定结束的通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver_bound(dev);</span><br></pre></td></tr></table></figure>
<h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p>class是设备高级别的抽象，屏蔽了设备底层的实现细节。class结构在内核中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">class_attribute</span>		*<span class="title">class_attrs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span>		*<span class="title">dev_attrs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span>		*<span class="title">dev_bin_attrs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>			*<span class="title">dev_kobj</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">	<span class="keyword">char</span> *(*devnode)(struct device *dev, <span class="keyword">umode_t</span> *mode);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> (*class_release)(struct class *class);</span><br><span class="line">	<span class="keyword">void</span> (*dev_release)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*suspend)(struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">	<span class="keyword">int</span> (*resume)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *<span class="title">ns_type</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">namespace</span>)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>name：描述class的名字。</p>
<p>owner：指向class所属的模块。</p>
<p>class_attrs：class对象的属性文件。</p>
<p>dev_attrs：class关联的设备的属性文件。</p>
<p>dev_bin_attrs：属于该class的设备的二进制文件。</p>
<p>dev_kobj：class的kobject对象。</p>
<p>dev_uevent：当一个设备添加到该class或从该class移除时调用，或者其它情况生成uevent事件时调用。</p>
<p>devnode：用来在/dev/目录下创建设备文件时回调。</p>
<p>class_release：用来释放class。</p>
<p>dev_release：用来释放class中的设备。</p>
<p>suspend：使该class中的设备进入睡眠模式时调用。</p>
<p>resume：从睡眠模式中唤醒设备时调用。</p>
<p>namespace：该class的命名空间。</p>
<p>pm：电源关联相关操作集合。</p>
<p>p：驱动核心私有数据。该结构和总线中的p成员相同。</p>
<h4 id="创建和注册"><a href="#创建和注册" class="headerlink" title="创建和注册"></a>创建和注册</h4><p>class的创建和注册接口为class_create，class单独的注册接口为class_register，class_create和class_register都是调用__class_register函数注册的。在这里只关注class_create接口。</p>
<p>class_create是一个宏函数，其真正调用的是__class_create函数。</p>
<p>在__class_create函数中，首先创建class对象，并根据初始化其名称和所属模块，然后设置其class_reliase回调函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cls = kzalloc(<span class="keyword">sizeof</span>(*cls), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">	retval = -ENOMEM;</span><br><span class="line">	<span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cls-&gt;name = name;</span><br><span class="line">cls-&gt;owner = owner;</span><br><span class="line">cls-&gt;class_release = class_create_release;</span><br></pre></td></tr></table></figure>
<p>然后调用__class_register函数注册刚创建的class：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">retval = __class_register(cls, key);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> error;</span><br></pre></td></tr></table></figure>
<p>在__class_register函数中首先为class的p成员申请空间并初始化其设备链表头，interfaces链表头，sysfs关联目录的名称等：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cp = kzalloc(<span class="keyword">sizeof</span>(*cp), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!cp)</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">klist_init(&amp;cp-&gt;klist_devices, klist_class_dev_get, klist_class_dev_put);</span><br><span class="line">INIT_LIST_HEAD(&amp;cp-&gt;interfaces);</span><br><span class="line">kset_init(&amp;cp-&gt;glue_dirs);</span><br><span class="line">__mutex_init(&amp;cp-&gt;mutex, <span class="string">"subsys mutex"</span>, key);</span><br><span class="line">error = kobject_set_name(&amp;cp-&gt;subsys.kobj, <span class="string">"%s"</span>, cls-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">	kfree(cp);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着设置class包含的设备在sysfs下所属的目录为/sys/dev目录：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set the default /sys/dev directory for devices of this class */</span></span><br><span class="line"><span class="keyword">if</span> (!cls-&gt;dev_kobj)</span><br><span class="line">	cls-&gt;dev_kobj = sysfs_dev_char_kobj;</span><br></pre></td></tr></table></figure>
<p>然后设置其所属的kset对象为class_kset，即class被注册到的sysfs目录为/sys/class目录。接着调用kset_register将该class注册到/sys/class目录中。再接着通过add_class_attrs向其注册的目录中添加class的属性文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cp-&gt;subsys.kobj.kset = class_kset;</span><br><span class="line">cp-&gt;subsys.kobj.ktype = &amp;class_ktype;</span><br><span class="line">cp-&gt;<span class="class"><span class="keyword">class</span> = <span class="title">cls</span>;</span></span><br><span class="line">cls-&gt;p = cp;</span><br><span class="line"></span><br><span class="line">error = kset_register(&amp;cp-&gt;subsys);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">	kfree(cp);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">error = add_class_attrs(class_get(cls));</span><br></pre></td></tr></table></figure>
<h4 id="向class添加设备"><a href="#向class添加设备" class="headerlink" title="向class添加设备"></a>向class添加设备</h4><p>向class中创建设备的接口是device_create函数，该函数主要通过调用device_create_vargs函数添加设备，在device_create_vargs函数中，先创建了device对象，并根据传入参数设置了其devt和class以及parent属性。并设置了device对象的release回调函数，以及device对象的drvdata：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dev = kzalloc(<span class="keyword">sizeof</span>(*dev), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!dev) &#123;</span><br><span class="line">	retval = -ENOMEM;</span><br><span class="line">	<span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dev-&gt;devt = devt;</span><br><span class="line">dev-&gt;<span class="class"><span class="keyword">class</span> = <span class="title">class</span>;</span></span><br><span class="line">dev-&gt;parent = parent;</span><br><span class="line">dev-&gt;release = device_create_release;</span><br><span class="line">dev_set_drvdata(dev, drvdata);</span><br></pre></td></tr></table></figure>
<p>最后根据传入的参数设置了device对象在sysfs中名字，并调用device_register函数将设备添加到总线和sysfs中，正如在Devices章节分析的那样，这里设置了device对象的class成员和devt成员后，在device_register函数中不但会将该device对象添加到/sys/devices中，并且会在该class对应/sys/class中的目录中创建该设备的链接，同时在/sys/dev/目录下创建该设备的链接，同时也会在devtmpfs中创建设备节点。</p>
<h2 id="dev下设备文件的创建"><a href="#dev下设备文件的创建" class="headerlink" title="/dev下设备文件的创建"></a>/dev下设备文件的创建</h2><p>在linux系统中，可以通过mknod程序手动创建设备文件。</p>
<p>在较早版本的内核中，可以在内核中创建class，并在class中创建device对象并设置device对象的devno，这样注册到sysfs的device对象会在/sys/class目录中对应的class目录中创建device对象的链接文件。当系统启动初始化的时候，用户空间的udev或者mdev程序可以扫描/sys/class目录，对具有设备号的设备自动在/dev/目录下为其创建设备文件。</p>
<p>在较新版本的内核中引入了devtmpfs的概念，对于属于class和有devno的device对象，在其注册阶段就会在devtmpfs中创建设备文件，系统启动后不需要udev或mdev的扫描，直接通过下面的命令挂载devtmpfs到/dev目录即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t devtmpfs none /dev</span><br></pre></td></tr></table></figure>
<h2 id="内核uevent向用户空间的通知"><a href="#内核uevent向用户空间的通知" class="headerlink" title="内核uevent向用户空间的通知"></a>内核uevent向用户空间的通知</h2><h3 id="内核发送事件"><a href="#内核发送事件" class="headerlink" title="内核发送事件"></a>内核发送事件</h3><p>从设备驱动模型各组件的注册过程可知内核通过kobject_uevent函数向用户空间发送通知，kobject_uevent函数大概流程如下：</p>
<p>1.通过发送事件的kobject获取到其kset对象，从kset中获取到其kset_uevent_ops。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* search the kset we belong to */</span></span><br><span class="line">top_kobj = kobj;</span><br><span class="line"><span class="keyword">while</span> (!top_kobj-&gt;kset &amp;&amp; top_kobj-&gt;parent)</span><br><span class="line">	top_kobj = top_kobj-&gt;parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!top_kobj-&gt;kset) &#123;</span><br><span class="line">	pr_debug(<span class="string">"kobject: '%s' (%p): %s: attempted to send uevent "</span></span><br><span class="line">			<span class="string">"without kset!\n"</span>, kobject_name(kobj), kobj,</span><br><span class="line">			__func__);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kset = top_kobj-&gt;kset;</span><br><span class="line">uevent_ops = kset-&gt;uevent_ops;</span><br></pre></td></tr></table></figure>
<p>2.判断该kobj本事是否设置了uevent_suppress，该属性不为零表示该kobject对象不发送uevent。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* skip the event, if uevent_suppress is set*/</span></span><br><span class="line"><span class="keyword">if</span> (kobj-&gt;uevent_suppress) &#123;</span><br><span class="line">	pr_debug(<span class="string">"kobject: '%s' (%p): %s: uevent_suppress "</span></span><br><span class="line">				<span class="string">"caused the event to drop!\n"</span>,</span><br><span class="line">				kobject_name(kobj), kobj, __func__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.执行kset_uevent_ops中的filter回调函数，已确定该kobj的事件是否被过滤。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* skip the event, if the filter returns zero. */</span></span><br><span class="line"><span class="keyword">if</span> (uevent_ops &amp;&amp; uevent_ops-&gt;filter)</span><br><span class="line">	<span class="keyword">if</span> (!uevent_ops-&gt;filter(kset, kobj)) &#123;</span><br><span class="line">		pr_debug(<span class="string">"kobject: '%s' (%p): %s: filter function "</span></span><br><span class="line">			 <span class="string">"caused the event to drop!\n"</span>,</span><br><span class="line">			 kobject_name(kobj), kobj, __func__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>4.确定其subsystem名字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* originating subsystem */</span></span><br><span class="line"><span class="keyword">if</span> (uevent_ops &amp;&amp; uevent_ops-&gt;name)</span><br><span class="line">	subsystem = uevent_ops-&gt;name(kset, kobj);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	subsystem = kobject_name(&amp;kset-&gt;kobj);</span><br><span class="line"><span class="keyword">if</span> (!subsystem) &#123;</span><br><span class="line">	pr_debug(<span class="string">"kobject: '%s' (%p): %s: unset subsystem caused the "</span></span><br><span class="line">			<span class="string">"event to drop!\n"</span>, kobject_name(kobj), kobj,</span><br><span class="line">			__func__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.申请环境变量buf，设置环境变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* environment buffer */</span></span><br><span class="line">env = kzalloc(<span class="keyword">sizeof</span>(struct kobj_uevent_env), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!env)</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* complete object path */</span></span><br><span class="line">devpath = kobject_get_path(kobj, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!devpath) &#123;</span><br><span class="line">	retval = -ENOENT;</span><br><span class="line">	<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* default keys */</span></span><br><span class="line">retval = add_uevent_var(env, <span class="string">"ACTION=%s"</span>, action_string);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">retval = add_uevent_var(env, <span class="string">"DEVPATH=%s"</span>, devpath);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">retval = add_uevent_var(env, <span class="string">"SUBSYSTEM=%s"</span>, subsystem);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* keys passed in from the caller */</span></span><br><span class="line"><span class="keyword">if</span> (envp_ext) &#123;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; envp_ext[i]; i++) &#123;</span><br><span class="line">		retval = add_uevent_var(env, <span class="string">"%s"</span>, envp_ext[i]);</span><br><span class="line">		<span class="keyword">if</span> (retval)</span><br><span class="line">			<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.如果是添加或移除事件，在kobject对象中的相关属性中标记，以确保该kobject能正确的被cleanup，同时向环境变量缓冲区中设置事件序号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Mark "add" and "remove" events in the object to ensure proper</span></span><br><span class="line"><span class="comment"> * events to userspace during automatic cleanup. If the object did</span></span><br><span class="line"><span class="comment"> * send an "add" event, "remove" will automatically generated by</span></span><br><span class="line"><span class="comment"> * the core, if not already done by the caller.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (action == KOBJ_ADD)</span><br><span class="line">	kobj-&gt;state_add_uevent_sent = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (action == KOBJ_REMOVE)</span><br><span class="line">	kobj-&gt;state_remove_uevent_sent = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;uevent_sock_mutex);</span><br><span class="line"><span class="comment">/* we will send an event, so request a new sequence number */</span></span><br><span class="line">retval = add_uevent_var(env, <span class="string">"SEQNUM=%llu"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)++uevent_seqnum);</span><br><span class="line"><span class="keyword">if</span> (retval) &#123;</span><br><span class="line">	mutex_unlock(&amp;uevent_sock_mutex);</span><br><span class="line">	<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7.将事件和其环境变量缓冲区内容通过netlink发送到用户空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* send netlink message */</span></span><br><span class="line">list_for_each_entry(ue_sk, &amp;uevent_sock_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">uevent_sock</span> = <span class="title">ue_sk</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!netlink_has_listeners(uevent_sock, <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">		retval = netlink_broadcast_filtered(uevent_sock, skb,</span><br><span class="line">						    <span class="number">0</span>, <span class="number">1</span>, GFP_KERNEL,</span><br><span class="line">						    kobj_bcast_filter,</span><br><span class="line">						    kobj);</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8.如果用户空间设置了uevent_helper程序，则通过call_usermodehelper调用该程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* call uevent_helper, usually only enabled during early boot */</span></span><br><span class="line"><span class="keyword">if</span> (uevent_helper[<span class="number">0</span>] &amp;&amp; !kobj_usermode_filter(kobj)) &#123;</span><br><span class="line">	<span class="keyword">char</span> *argv [<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	argv [<span class="number">0</span>] = uevent_helper;</span><br><span class="line">	argv [<span class="number">1</span>] = (<span class="keyword">char</span> *)subsystem;</span><br><span class="line">	argv [<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line">	retval = add_uevent_var(env, <span class="string">"HOME=/"</span>);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">	retval = add_uevent_var(env,</span><br><span class="line">				<span class="string">"PATH=/sbin:/bin:/usr/sbin:/usr/bin"</span>);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">	retval = call_usermodehelper(argv[<span class="number">0</span>], argv,</span><br><span class="line">				     env-&gt;envp, UMH_WAIT_EXEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用户空间处理事件"><a href="#用户空间处理事件" class="headerlink" title="用户空间处理事件"></a>用户空间处理事件</h3><p>用户空间一般用mdev/udev工具处理内核发送到用户空间的事件。内核一般用两种机制完成该过程，一种是通过netlink网络将事件信息发送到用户mdev/udev守护进程。一种是直接调用用户程序，这就要求用户空间向内核设置一个用户空间处理事件的程序，需内核开启CONFIG_HOTPLUG配置，以可通过procfs或sysfs向内核设置该程序，默认由CONFIG_UEVENT_HELPER_PATH配置设定，一般的默认设置是/sbin/hotplug，通过sysfs或procfs设置方法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">echo /sbin/mdev &gt; /sys/kernel/uevent_helper</span><br></pre></td></tr></table></figure>
<p>以mdev为例说明，mdev主要负责两个功能，第一是在系统启动的时候扫描/sys/class目录，将该目录下有设备号的设备在/dev/目录下创建设备文件。第二个功能就是接受内核uevent事件，在/dev下动态添加设备或改变设备的属性。</p>
<h2 id="设备驱动模型应用实例"><a href="#设备驱动模型应用实例" class="headerlink" title="设备驱动模型应用实例"></a>设备驱动模型应用实例</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>通过一个简单的设备驱动模型的应用实例验证设备驱动模型。</p>
<p>内核samples代码由关于kset和kobject的测试代码，在这里直接使用一些原有的对象，在其基础之上做进一步验证。</p>
<p>实现一个ddm（device driver model）模块，向系统中注册一个新的总线ddm，并为其注册设备的父设备为ddm_bus设备，在注册总线之后，将总线上的drivers_autoprobe属性值设置为0，是为了手动绑定ddm总线上的设备和驱动。然后定义一种ddm_device类型的设备和ddm_driver类型的驱动，总线上简单的通过名字的比较匹配ddm设备和ddm驱动。并实现ddm设备的注册和取消注册接口以及ddm驱动的注册和取消注册接口。在模块加载函数中注册总线设备父设备以及总线，之后再注册一个ddm驱动和两个ddm设备，以此来验证设备驱动模型。在用户空间sysfs视角，该模块实现以下功能：</p>
<p>1.在/sys/devices目录中新增ddm_bus目录，在ddm_bus目录中存在ddm_driver-0和ddm_driver-1两个目录。</p>
<p>2.在/sys/bus目录中新增ddm目录，在ddm目录的driver目录中存在ddm_driver目录以及ddm_driver-0和ddm_driver-1两个目录的链接文件。</p>
<p>3.在/sys/module下新增ddm目录，在ddm目录中存在ddm_driver目录的链接文件。</p>
<h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_ddm_device(x) container_of((x), struct ddm_device, dev)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_ddm_driver(x) container_of((x), struct ddm_driver, driver)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">subsys</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">devices_kset</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">interfaces</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">drivers_kset</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_drivers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">bus_notifier</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> drivers_autoprobe:<span class="number">1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">glue_dirs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">class</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ddm device struct</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ddm_device</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ddm driver struct</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ddm_driver</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ddm_device_release</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">"%s\n"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">ddm_bus</span> = &#123;</span></span><br><span class="line">	.init_name = <span class="string">"ddm_bus"</span>,</span><br><span class="line">	.release = ddm_device_release,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ddev_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * match according the name of dev's container and drv.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ddm_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ddm_device</span> *<span class="title">ddev</span> = <span class="title">to_ddm_device</span>(<span class="title">dev</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">strcmp</span>(ddev-&gt;name, drv-&gt;name) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">ddm_bus_type</span> = &#123;</span></span><br><span class="line">	.name = <span class="string">"ddm"</span>,</span><br><span class="line">	.match = ddm_match,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ddm_device_register</span><span class="params">(struct ddm_device *ddev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!ddev)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	device_initialize(&amp;ddev-&gt;dev);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!ddev-&gt;dev.parent)</span><br><span class="line">		ddev-&gt;dev.parent = &amp;ddm_bus;</span><br><span class="line">	ddev-&gt;dev.bus = &amp;ddm_bus_type;</span><br><span class="line">	ddev-&gt;dev.release = ddm_device_release;</span><br><span class="line"></span><br><span class="line">	ddev-&gt;id = ddev_id++;</span><br><span class="line">	dev_set_name(&amp;ddev-&gt;dev, <span class="string">"%s-%d"</span>, ddev-&gt;name, ddev-&gt;id);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> device_add(&amp;ddev-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ddm_device_unregister</span><span class="params">(struct ddm_device *ddev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!ddev)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	device_del(&amp;ddev-&gt;dev);</span><br><span class="line">	put_device(&amp;ddev-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ddm_driver_register</span><span class="params">(struct ddm_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	drv-&gt;driver.bus = &amp;ddm_bus_type;</span><br><span class="line">	<span class="keyword">if</span> (!drv-&gt;driver.probe || !drv-&gt;driver.remove) &#123;</span><br><span class="line">		printk(<span class="string">"ddm driver need the device_driver initialized\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> driver_register(&amp;drv-&gt;driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ddm_driver_unregister</span><span class="params">(struct ddm_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	driver_unregister(&amp;drv-&gt;driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ddm_driver_probe</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ddm_device</span> *<span class="title">ddev</span> = <span class="title">to_ddm_device</span>(<span class="title">dev</span>);</span></span><br><span class="line">	printk(<span class="string">"%s:ddm device %s-%d probed\n"</span>, __func__, ddev-&gt;name, ddev-&gt;id);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ddm_driver_remove</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ddm_device</span> *<span class="title">ddev</span> = <span class="title">to_ddm_device</span>(<span class="title">dev</span>);</span></span><br><span class="line">	printk(<span class="string">"%s:ddm device %s-%d removed\n"</span>, __func__, ddev-&gt;name, ddev-&gt;id);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ddm_driver</span> <span class="title">test_driver</span> = &#123;</span></span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.owner = THIS_MODULE,</span><br><span class="line">		.name = <span class="string">"ddm_driver"</span>,</span><br><span class="line">		.probe = ddm_driver_probe,</span><br><span class="line">		.remove = ddm_driver_remove,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ddm_device</span> <span class="title">test_devices</span>[] = &#123;</span></span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"ddm_driver"</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"ddm_driver"</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">ddm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ddm_device</span> *<span class="title">ddev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*register the parent device of this bus type*/</span></span><br><span class="line">	error = device_register(&amp;ddm_bus);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*register the bus type*/</span></span><br><span class="line">	error = bus_register(&amp;ddm_bus_type);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> unregister_device;</span><br><span class="line">	ddm_bus_type.p-&gt;drivers_autoprobe = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*register driver to ddm_bus_type */</span></span><br><span class="line">	error = ddm_driver_register(&amp;test_driver);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		<span class="keyword">goto</span> unregister_bus;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(test_devices); i++) &#123;</span><br><span class="line">		error = ddm_device_register(&amp;test_devices[i]);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> unregister_dev;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*register devices to ddm_bus_type */</span></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">unregister_dev:</span><br><span class="line">	ddev = &amp;test_devices[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">while</span> (i--)</span><br><span class="line">		ddm_device_unregister(ddev++);</span><br><span class="line">	ddm_driver_unregister(&amp;test_driver);</span><br><span class="line">unregister_bus:</span><br><span class="line">	bus_unregister(&amp;ddm_bus_type);</span><br><span class="line">unregister_device:</span><br><span class="line">	device_unregister(&amp;ddm_bus);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">ddm_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(test_devices); i++)</span><br><span class="line">		ddm_device_unregister(&amp;test_devices[i]);</span><br><span class="line">	ddm_driver_unregister(&amp;test_driver);</span><br><span class="line">	bus_unregister(&amp;ddm_bus_type);</span><br><span class="line">	device_unregister(&amp;ddm_bus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(ddm_init);</span><br><span class="line">module_exit(ddm_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"shad"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"Device driver model test!"</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">"DDM_V0.1"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="实例测试"><a href="#实例测试" class="headerlink" title="实例测试"></a>实例测试</h3><p>将实例代码编译成模块文件ddm.ko，将ddm.ko通过insmod程序加载到内核后可以看到：</p>
<p>1.在/sys/module目录下出现ddm目录，该目录的drivers目录中中存在指向/sys/bus/ddm/drivers/ddm_driver目录的链接文件。</p>
<p>2./sys/bus目录中出现ddm目录，在该ddm目录中的drivers目录下有一个ddm_driver目录，devices目录下有两个链接文件ddm_driver-0和ddm_driver-1</p>
<p>3.在/sys/devices目录中出现ddm_bus目录，该目录中有ddm_driver-0和ddm_driver-1两个目录。</p>
<p>以上现象说明模块实例成功向内核注册了ddm总线，并在ddm总线上注册了一个ddm_driver和两个设备（ddm_driver-0和ddm_driver-1）。</p>
<p>接下来向/sys/bus/ddm/drivers_probe或者/sys/bus/ddm/drivers/ddm_driver/bind文件中写入“ddm_driver-0”：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo ddm_driver-0 &gt; /sys/bus/ddm/drivers_probe 或者</span><br><span class="line">echo ddm_driver-0 &gt; /sys/bus/ddm/drivers/ddm_driver/bind</span><br></pre></td></tr></table></figure>
<p>出现的新现象为：在/sys/bus/ddm/drivers/ddm_driver目录中出现了ddm_driver-0的链接文件，指向/sys/devices/ddm_bus/ddm_driver-0目录。在/sys/bus/ddm/devices/ddm_driber-0目录中出现了driver链接文件，指向/sys/bus/ddm/drivers/ddm_driver。</p>
<p>以上现象说明，通过向总线的drivers_probe或者驱动的bind属性文件写入要绑定的设备名后，内核成功将了匹配到的设备和驱动建立绑定关系。</p>
</div><div class="tags"><a href="/tags/device-driver/">device driver</a></div><div class="post-nav"><a class="pre" href="/2020/02/29/Linux内核通知链/">Linux内核通知链</a><a class="next" href="/2019/11/26/ARM-LINUX中断系统/">ARM-LINUX中断系统</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  id: window.location.pathname.substring(1,window.location.pathname.length),
  owner: 'geekchenxd',
  repo: 'geekchenxd.github.io',
  oauth: {
    client_id: '00f3259791ebc5b5d412',
    client_secret: 'd88056bc0050337d5767e26f8d228f526ed7687d',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://www.chenxd.xyz"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel/">Kernel</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/qemu/">qemu</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Debug/" style="font-size: 15px;">Debug</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/notification/" style="font-size: 15px;">notification</a> <a href="/tags/subsystem/" style="font-size: 15px;">subsystem</a> <a href="/tags/initcall/" style="font-size: 15px;">initcall</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/watchdog/" style="font-size: 15px;">watchdog</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/arm/" style="font-size: 15px;">arm</a> <a href="/tags/dtb/" style="font-size: 15px;">dtb</a> <a href="/tags/dts/" style="font-size: 15px;">dts</a> <a href="/tags/file-system/" style="font-size: 15px;">file_system</a> <a href="/tags/usb/" style="font-size: 15px;">usb</a> <a href="/tags/Interrupt/" style="font-size: 15px;">Interrupt</a> <a href="/tags/device-driver/" style="font-size: 15px;">device driver</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/05/Linux内核调试之KGDB/">Linux内核调试之KGDB</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/Qemu虚拟Arm开发板/">Qemu虚拟Arm开发板</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/Linux内核通知链/">Linux内核通知链</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/Linux内核设备驱动模型/">Linux内核设备驱动模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/26/ARM-LINUX中断系统/">ARM-LINUX中断系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/25/Linux内核之看门狗子系统/">Linux内核之看门狗子系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/24/Linux内核之虚拟文件系统/">Linux内核之虚拟文件系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/28/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/09/Linux内核usb子系统/">Linux内核usb子系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/09/Linux内核initcall过程/">Linux内核initcall过程</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.github.com" title="github" target="_blank">github</a><ul></ul><a href="http://www.kernel.org" title="linux kernel" target="_blank">linux kernel</a><ul></ul><a href="http://www.combatpress.com/" title="Combat Press" target="_blank">Combat Press</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Evil Code.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>