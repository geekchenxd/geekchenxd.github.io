<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Code controls all the hardware"><title>ARM-LINUX中断系统 | Evil Code</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ARM-LINUX中断系统</h1><a id="logo" href="/.">Evil Code</a><p class="description">Coding Change The World</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ARM-LINUX中断系统</h1><div class="post-meta">Nov 26, 2019<span> | </span><span class="category"><a href="/categories/Kernel/">Kernel</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-ARM中断处理流程"><span class="toc-number">1.</span> <span class="toc-text">一.ARM中断处理流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-Linux内核对中断异常的处理"><span class="toc-number">2.</span> <span class="toc-text">二.Linux内核对中断异常的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-Linux中断控制器初始化"><span class="toc-number">3.</span> <span class="toc-text">三.Linux中断控制器初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内核中对中断控制器的描述"><span class="toc-number">3.1.</span> <span class="toc-text">内核中对中断控制器的描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核中对中断的描述"><span class="toc-number">3.2.</span> <span class="toc-text">内核中对中断的描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断控制器初始化流程"><span class="toc-number">3.3.</span> <span class="toc-text">中断控制器初始化流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断控制器的驱动识别"><span class="toc-number">3.4.</span> <span class="toc-text">中断控制器的驱动识别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#根中断控制器初始化"><span class="toc-number">3.5.</span> <span class="toc-text">根中断控制器初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他中断控制器初始化"><span class="toc-number">3.6.</span> <span class="toc-text">其他中断控制器初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断系统框架"><span class="toc-number">3.7.</span> <span class="toc-text">中断系统框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-Linux中断处理过程"><span class="toc-number">4.</span> <span class="toc-text">四.Linux中断处理过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C语言入口函数"><span class="toc-number">4.1.</span> <span class="toc-text">C语言入口函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取当前中断cpu的中断号"><span class="toc-number">4.2.</span> <span class="toc-text">获取当前中断cpu的中断号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理中断"><span class="toc-number">4.3.</span> <span class="toc-text">处理中断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-在linux中使用中断"><span class="toc-number">5.</span> <span class="toc-text">五.在linux中使用中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在设备树中描述中断"><span class="toc-number">5.1.</span> <span class="toc-text">在设备树中描述中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在驱动程序中使用中断"><span class="toc-number">5.2.</span> <span class="toc-text">在驱动程序中使用中断</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="一-ARM中断处理流程"><a href="#一-ARM中断处理流程" class="headerlink" title="一.ARM中断处理流程"></a>一.ARM中断处理流程</h2><p>CPU每执行完一条指令，都会判断是否有异常发生，如果有异常发生，就跳转到相应的异常向量表的地址执行异常指令，该指令由软件设置，一般在系统内核启动的时候会设置异常向量表。</p>
<h2 id="二-Linux内核对中断异常的处理"><a href="#二-Linux内核对中断异常的处理" class="headerlink" title="二.Linux内核对中断异常的处理"></a>二.Linux内核对中断异常的处理</h2><p>代码位置：<code>arm/arm/kernel/entry-armv.S</code></p>
<p>Linux内核在系统启动的时候会设置异常向量表，该向量表代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.L__vectors_start:</span><br><span class="line">	W(b)	vector_rst</span><br><span class="line">	W(b)	vector_und</span><br><span class="line">	W(ldr)	pc, .L__vectors_start + 0x1000</span><br><span class="line">	W(b)	vector_pabt</span><br><span class="line">	W(b)	vector_dabt</span><br><span class="line">	W(b)	vector_addrexcptn</span><br><span class="line">	W(b)	vector_irq</span><br><span class="line">	W(b)	vector_fiq</span><br></pre></td></tr></table></figure>
<p>对于中断，该指令为一条跳转指令，跳转到vector_irq地址去执行指令，在内核中vactor_irq由一个宏来展开，该宏的名称是vector_stub：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">	.macro	vector_stub, name, mode, correction=0</span><br><span class="line">	.align	5</span><br><span class="line">vector_\name:</span><br><span class="line">	.if \correction</span><br><span class="line">	sub	lr, lr, #\correction</span><br><span class="line">	.endif</span><br><span class="line"></span><br><span class="line">	@</span><br><span class="line">	@ Save r0, lr_&lt;exception&gt; (parent PC) and spsr_&lt;exception&gt;</span><br><span class="line">	@ (parent CPSR)</span><br><span class="line">	@</span><br><span class="line">	stmia	sp, &#123;r0, lr&#125;		@ save r0, lr</span><br><span class="line">	mrs	lr, spsr</span><br><span class="line">	str	lr, [sp, #8]		@ save spsr</span><br><span class="line"></span><br><span class="line">	@</span><br><span class="line">	@ Prepare for SVC32 mode.  IRQs remain disabled.</span><br><span class="line">	@</span><br><span class="line">	mrs	r0, cpsr</span><br><span class="line">	eor	r0, r0, #(\mode ^ SVC_MODE | PSR_ISETSTATE)</span><br><span class="line">	msr	spsr_cxsf, r0</span><br><span class="line"></span><br><span class="line">	@</span><br><span class="line">	@ the branch table must immediately follow this code</span><br><span class="line">	@</span><br><span class="line">	and	lr, lr, #0x0f</span><br><span class="line"> THUMB(	adr	r0, 1f			)</span><br><span class="line"> THUMB(	ldr	lr, [r0, lr, lsl #2]	)</span><br><span class="line">	mov	r0, sp</span><br><span class="line"> ARM(	ldr	lr, [pc, lr, lsl #2]	)</span><br><span class="line">	movs	pc, lr			@ branch to handler in SVC mode</span><br><span class="line">ENDPROC(vector_\name)</span><br></pre></td></tr></table></figure>
<p>irq入口对该宏的引用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Interrupt dispatcher</span><br><span class="line"> */</span><br><span class="line">	vector_stub	irq, IRQ_MODE, 4</span><br><span class="line"></span><br><span class="line">	.long	__irq_usr			@  0  (USR_26 / USR_32)</span><br><span class="line">	.long	__irq_invalid			@  1  (FIQ_26 / FIQ_32)</span><br><span class="line">	.long	__irq_invalid			@  2  (IRQ_26 / IRQ_32)</span><br><span class="line">	.long	__irq_svc			@  3  (SVC_26 / SVC_32)</span><br><span class="line">	.long	__irq_invalid			@  4</span><br><span class="line">	.long	__irq_invalid			@  5</span><br><span class="line">	.long	__irq_invalid			@  6</span><br><span class="line">	.long	__irq_invalid			@  7</span><br><span class="line">	.long	__irq_invalid			@  8</span><br><span class="line">	.long	__irq_invalid			@  9</span><br><span class="line">	.long	__irq_invalid			@  a</span><br><span class="line">	.long	__irq_invalid			@  b</span><br><span class="line">	.long	__irq_invalid			@  c</span><br><span class="line">	.long	__irq_invalid			@  d</span><br><span class="line">	.long	__irq_invalid			@  e</span><br><span class="line">	.long	__irq_invalid			@  f</span><br></pre></td></tr></table></figure>
<p>上面代码中的中断分两种模式，usr和svc。在vector_stub宏内部的代码先对cpsr进行判断得知应该执行哪种处理。</p>
<p>svn模式的中断处理代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__irq_svc:</span><br><span class="line">	svc_entry</span><br><span class="line">	irq_handler</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_PREEMPT</span><br><span class="line">	ldr	r8, [tsk, #TI_PREEMPT]		@ get preempt count</span><br><span class="line">	ldr	r0, [tsk, #TI_FLAGS]		@ get flags</span><br><span class="line">	teq	r8, #0				@ if preempt count != 0</span><br><span class="line">	movne	r0, #0				@ force flags to 0</span><br><span class="line">	tst	r0, #_TIF_NEED_RESCHED</span><br><span class="line">	blne	svc_preempt</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	svc_exit r5, irq = 1			@ return from exception</span><br><span class="line"> UNWIND(.fnend		)</span><br><span class="line">ENDPROC(__irq_svc)</span><br></pre></td></tr></table></figure>
<p>usr模式的中断处理代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__irq_usr:</span><br><span class="line">	usr_entry</span><br><span class="line">	kuser_cmpxchg_check</span><br><span class="line">	irq_handler</span><br><span class="line">	get_thread_info tsk</span><br><span class="line">	mov	why, #0</span><br><span class="line">	b	ret_to_user_from_irq</span><br><span class="line"> UNWIND(.fnend		)</span><br><span class="line">ENDPROC(__irq_usr)</span><br></pre></td></tr></table></figure>
<p>由上面两种模式的关键处理代码可知，它们都会保存中断现场，然后调用到irq_handler，然后恢复现场。</p>
<p>irq_handler也是一个宏定义，该宏的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Interrupt handling.</span><br><span class="line"> */</span><br><span class="line">	.macro	irq_handler</span><br><span class="line">#ifdef CONFIG_MULTI_IRQ_HANDLER</span><br><span class="line">	ldr	r1, =handle_arch_irq</span><br><span class="line">	mov	r0, sp</span><br><span class="line">	badr	lr, 9997f</span><br><span class="line">	ldr	pc, [r1]</span><br><span class="line">#else</span><br><span class="line">	arch_irq_handler_default</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>由上面的代码可直，最终调用的中断处理函数为handle_arch_irq，该函数是一个C语言函数指针，总结内核对中断异常处理的汇编部分如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.cpu产生中断异常，跳转到异常向量表中断异常的地址执行汇编中断处理代码</span><br><span class="line">2.汇编中断处理代码保存中断现场</span><br><span class="line">3.汇编中断处理代码调用C语言中断处理函数</span><br><span class="line">4.汇编中断处理代码恢复中断现场</span><br></pre></td></tr></table></figure>
<h2 id="三-Linux中断控制器初始化"><a href="#三-Linux中断控制器初始化" class="headerlink" title="三.Linux中断控制器初始化"></a>三.Linux中断控制器初始化</h2><h3 id="内核中对中断控制器的描述"><a href="#内核中对中断控制器的描述" class="headerlink" title="内核中对中断控制器的描述"></a>内核中对中断控制器的描述</h3><p>在linux内核中每一个中断控制器有一个irq_domain结构体，内核维护了一个irq_domain链表。irq_domain结构体在内核中的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct irq_domain &#123;</span><br><span class="line">	struct list_head link;</span><br><span class="line">	const char *name;</span><br><span class="line">	const struct irq_domain_ops *ops;</span><br><span class="line">	void *host_data;</span><br><span class="line">	unsigned int flags;</span><br><span class="line"></span><br><span class="line">	/* Optional data */</span><br><span class="line">	struct fwnode_handle *fwnode;</span><br><span class="line">	enum irq_domain_bus_token bus_token;</span><br><span class="line">	struct irq_domain_chip_generic *gc;</span><br><span class="line">#ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY</span><br><span class="line">	struct irq_domain *parent;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* reverse map data. The linear map gets appended to the irq_domain */</span><br><span class="line">	irq_hw_number_t hwirq_max;</span><br><span class="line">	unsigned int revmap_direct_max_irq;</span><br><span class="line">	unsigned int revmap_size;</span><br><span class="line">	struct radix_tree_root revmap_tree;</span><br><span class="line">	unsigned int linear_revmap[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>link</strong>：链表元素，用来将irq_domain链入全局链表。</p>
<p><strong>name</strong>：该中断域的名字。</p>
<p><strong>ops</strong>：irq_domain的操作方法集。该集合中有两个常用的函数指针，map指针用来在一个irq_domain上为中断号和硬件中断号建立映射关系，在map函数中一般会设置virq对应的irq_desc结构的irq_data成员以及handle_irq回调函数；xlate函数用来获取中断类型和描述。</p>
<p><strong>of_node</strong>：关联到该irq_domain的设备树节点。</p>
<p><strong>host_data</strong>：私有数据指针。</p>
<p><strong>gc</strong>：irq_chip_generic链表。描述irq_chip。每个irq_chip_generic维护一个irq_chip_type表，用来表示一个irq_chip实例。</p>
<p><strong>parent</strong>：该riq_domain的父节点。</p>
<p><strong>hwirq_max</strong>：最大硬件中断号。</p>
<p><strong>revmap_size</strong>：线性映射表的大小。</p>
<p><strong>linear_revmap</strong>:线性反向映射表，是一个整数数组，用来记录硬件中断号和中断号的关系。该数组下标为硬件中断号，数组项为以该下标为硬件中断号对应的中断号。</p>
<h3 id="内核中对中断的描述"><a href="#内核中对中断的描述" class="headerlink" title="内核中对中断的描述"></a>内核中对中断的描述</h3><p>linux内核中维护了一个irq_desc结构类型数组，数组的每一项表示一个中断。该结构在内核中的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">struct irq_desc &#123;</span><br><span class="line">	struct irq_common_data	irq_common_data;</span><br><span class="line">	struct irq_data		qirq_data;</span><br><span class="line">	unsigned int __percpu	*kstat_irqs;</span><br><span class="line">	irq_flow_handler_t	handle_irq;</span><br><span class="line">#ifdef CONFIG_IRQ_PREFLOW_FASTEOI</span><br><span class="line">	irq_preflow_handler_t	preflow_handler;</span><br><span class="line">#endif</span><br><span class="line">	struct irqaction	*action;	/* IRQ action list */</span><br><span class="line">	unsigned int		status_use_accessors;</span><br><span class="line">	unsigned int		core_internal_state__do_not_mess_with_it;</span><br><span class="line">	unsigned int		depth;		/* nested irq disables */</span><br><span class="line">	unsigned int		wake_depth;	/* nested wake enables */</span><br><span class="line">	unsigned int		irq_count;	/* For detecting broken IRQs */</span><br><span class="line">	unsigned long		last_unhandled;	/* Aging timer for unhandled count */</span><br><span class="line">	unsigned int		irqs_unhandled;</span><br><span class="line">	atomic_t		threads_handled;</span><br><span class="line">	int			threads_handled_last;</span><br><span class="line">	raw_spinlock_t		lock;</span><br><span class="line">	struct cpumask		*percpu_enabled;</span><br><span class="line">	const struct cpumask	*percpu_affinity;</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	const struct cpumask	*affinity_hint;</span><br><span class="line">	struct irq_affinity_notify *affinity_notify;</span><br><span class="line">#ifdef CONFIG_GENERIC_PENDING_IRQ</span><br><span class="line">	cpumask_var_t		pending_mask;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">	unsigned long		threads_oneshot;</span><br><span class="line">	atomic_t		threads_active;</span><br><span class="line">	wait_queue_head_t       wait_for_threads;</span><br><span class="line">#ifdef CONFIG_PM_SLEEP</span><br><span class="line">	unsigned int		nr_actions;</span><br><span class="line">	unsigned int		no_suspend_depth;</span><br><span class="line">	unsigned int		cond_suspend_depth;</span><br><span class="line">	unsigned int		force_resume_depth;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_PROC_FS</span><br><span class="line">	struct proc_dir_entry	*dir;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_SPARSE_IRQ</span><br><span class="line">	struct rcu_head		rcu;</span><br><span class="line">	struct kobject		kobj;</span><br><span class="line">#endif</span><br><span class="line">	int			parent_irq;</span><br><span class="line">	struct module		*owner;</span><br><span class="line">	const char		*name;</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>
<p>其中，irq_data成员用来描述该中断关联的中断域，软硬件中断号以及irq_chip等硬件相关的信息。handle_irq成员为该中断的处理回调函数。action成员为用户注册的中断处理的链表，在action中handler函数指针即为用户申请中断提供的中断处理函数，action列表一般由irq_desc的handle_irq函数遍历以调用所有用户注册的中断处理函数。比如一个共享中断，就可能会有多个action存在。</p>
<h3 id="中断控制器初始化流程"><a href="#中断控制器初始化流程" class="headerlink" title="中断控制器初始化流程"></a>中断控制器初始化流程</h3><p>在内核start_kernel中，首先会调用setup_arch函数，该函数会解析设备树，将设备树中的所有节点转换为device_node结构体，其中包含中断控制器节点。</p>
<p><code>drivers/of/irq.c</code></p>
<p>在setup_arch之后会调用到init_IRQ()函数，在该函数中调用irqchip_init()函数初始化中断控制器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extern struct of_device_id __irqchip_of_table[];</span><br><span class="line"></span><br><span class="line">void __init irqchip_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	of_irq_init(__irqchip_of_table);</span><br><span class="line">	acpi_probe_device_table(irqchip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数通过执行of_irq_init函数对__irqchip_of_table[]中的每一项和所有的device_node进行匹配，匹配到的device_node根据有没有”interrupt-controller”属性再进行判断，得到中断控制器节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for_each_matching_node_and_match(np, matches, &amp;match) &#123;</span><br><span class="line">		if (!of_find_property(np, &quot;interrupt-controller&quot;, NULL) ||</span><br><span class="line">				!of_device_is_available(np))</span><br><span class="line">			continue;</span><br></pre></td></tr></table></figure>
<p>接着为中断控制器节点申请一个of_intc_desc结构，并初始化该结构，该结构表示的中断控制器的初始化函数irq_init_cb被设置为匹配到的__irqchip_of_table数组中的of_device_id结构的data参数。接着将该结构添加至局部链表intc_desc_list中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">desc = kzalloc(sizeof(*desc), GFP_KERNEL);</span><br><span class="line">if (WARN_ON(!desc)) &#123;</span><br><span class="line">	of_node_put(np);</span><br><span class="line">	goto err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">desc-&gt;irq_init_cb = match-&gt;data;</span><br><span class="line">desc-&gt;dev = of_node_get(np);</span><br><span class="line">desc-&gt;interrupt_parent = of_irq_find_parent(np);</span><br><span class="line">if (desc-&gt;interrupt_parent == np)</span><br><span class="line">desc-&gt;interrupt_parent = NULL;</span><br><span class="line">list_add_tail(&amp;desc-&gt;list, &amp;intc_desc_list);</span><br></pre></td></tr></table></figure>
<p>将所有的中断控制器链入intc_desc_list后从父中断为NULL（根中断）的中断控制器开始遍历，并调用每一个中断控制器描述符中的初始化回调函数irq_init_cb，每初始化一个中断控制器并将其从局部链表intc_desc_list删除，并添加到局部链表intc_parent_list中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, list) &#123;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	if (desc-&gt;interrupt_parent != parent)</span><br><span class="line">		continue;</span><br><span class="line"></span><br><span class="line">	list_del(&amp;desc-&gt;list);</span><br><span class="line"></span><br><span class="line">	of_node_set_flag(desc-&gt;dev, OF_POPULATED);</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;of_irq_init: init %s (%p), parent %p\n&quot;,</span><br><span class="line">			desc-&gt;dev-&gt;full_name,</span><br><span class="line">			desc-&gt;dev, desc-&gt;interrupt_parent);</span><br><span class="line">	ret = desc-&gt;irq_init_cb(desc-&gt;dev,</span><br><span class="line">				desc-&gt;interrupt_parent);</span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		of_node_clear_flag(desc-&gt;dev, OF_POPULATED);</span><br><span class="line">		kfree(desc);</span><br><span class="line">		continue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">		* This one is now set up; add it to the parent list so</span><br><span class="line">		* its children can get processed in a subsequent pass.</span><br><span class="line">		*/</span><br><span class="line">	list_add_tail(&amp;desc-&gt;list, &amp;intc_parent_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取出intc_parent_list中的中断控制器，以该中断控制器作为父亲中断控制器，并重复上面的操作，依次执行所有中断控制器的初始化函数完成所有中断控制器的初始化工作，将初始化完的中断控制器从局部链表intc_parent_list中删除并删除所有申请的of_intc_desc结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Get the next pending parent that might have children */</span><br><span class="line">desc = list_first_entry_or_null(&amp;intc_parent_list,</span><br><span class="line">				typeof(*desc), list);</span><br><span class="line">if (!desc) &#123;</span><br><span class="line">	pr_err(&quot;of_irq_init: children remain, but no parents\n&quot;);</span><br><span class="line">	break;</span><br><span class="line">&#125;</span><br><span class="line">list_del(&amp;desc-&gt;list);</span><br><span class="line">parent = desc-&gt;dev;</span><br><span class="line">kfree(desc);</span><br></pre></td></tr></table></figure>
<h3 id="中断控制器的驱动识别"><a href="#中断控制器的驱动识别" class="headerlink" title="中断控制器的驱动识别"></a>中断控制器的驱动识别</h3><p>前面说的中断控制器初始化接口中遍历所有中断控制器的device_node，并从__irqchip_of_table数组中为其匹配到一项，并将其data参数作为初始化接口执行。在这里匹配过程是根据of_device_id中的compatible属性和设备树节点device_node中的属性列表中的compatible属性进行匹配的。而该数组中的每一项元素都由驱动代码添加。</p>
<p>在中断控制器驱动中通过IRQCHIP_DECLARE宏向该数组中添加驱动支持的设备描述，该宏的实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQCHIP_DECLARE(name, compat, fn) OF_DECLARE_2(irqchip, name, compat, fn)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OF_DECLARE_2(table, name, compat, fn) \</span></span><br><span class="line">        _OF_DECLARE(table, name, compat, fn, of_init_fn_2)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _OF_DECLARE(table, name, compat, fn, fn_type)           \</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> __<span class="title">of_table_</span>##<span class="title">name</span>      \</span></span><br><span class="line"><span class="class">        __<span class="title">used</span> __<span class="title">section</span>(__##<span class="title">table</span>##_<span class="title">of_table</span>)          \</span></span><br><span class="line"><span class="class">         = &#123;</span> .compatible = compat,              \</span><br><span class="line">             .data = (fn == (fn_type)<span class="literal">NULL</span>) ? fn : fn  &#125;</span><br></pre></td></tr></table></figure>
<p>该宏定义了一个与name相关名称的of_device_id结构并用传入的compat和data初始化该结构，它的段属性为__irqchip_of_table，内核编译的时候将这种段属性的地址放到和该段属性相同名字的地址处。</p>
<h3 id="根中断控制器初始化"><a href="#根中断控制器初始化" class="headerlink" title="根中断控制器初始化"></a>根中断控制器初始化</h3><p>以omap驱动为例，omap根中断控制器驱动代码文件为<code>drivers/irqchip/irq-omap-initc.c</code></p>
<p>在该代码中首先通过IRQCHIP_DECLARE添加多个驱动匹配的of_device_id，其中断控制器的初始化函数都为intc_of_init</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IRQCHIP_DECLARE(omap2_intc, &quot;ti,omap2-intc&quot;, intc_of_init);</span><br><span class="line">IRQCHIP_DECLARE(omap3_intc, &quot;ti,omap3-intc&quot;, intc_of_init);</span><br><span class="line">IRQCHIP_DECLARE(dm814x_intc, &quot;ti,dm814-intc&quot;, intc_of_init);</span><br><span class="line">IRQCHIP_DECLARE(dm816x_intc, &quot;ti,dm816-intc&quot;, intc_of_init);</span><br><span class="line">IRQCHIP_DECLARE(am33xx_intc, &quot;ti,am33xx-intc&quot;, intc_of_init);</span><br></pre></td></tr></table></figure>
<p>在前面所说中断控制器初始化流程中最终会调用到intc_of_init完成根中断控制器的初始化。</p>
<p>在intc_of_init函数中，首先执行omap_init_irq函数为根中断控制器申请并初始化irq_domain结构。然后通过set_handle_irq函数将omap_intc_handle_irq函数设置为中断处理的C入口函数，即最开始汇编代码调用的入口函数指针handle_arch_irq。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = omap_init_irq(-1, of_node_get(node));</span><br><span class="line">if (ret &lt; 0)</span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">set_handle_irq(omap_intc_handle_irq);</span><br></pre></td></tr></table></figure>
<p>irq_domain申请和初始化过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static int __init omap_init_irq_of(struct device_node *node)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	omap_irq_base = of_iomap(node, 0);</span><br><span class="line">	if (WARN_ON(!omap_irq_base))</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	domain = irq_domain_add_linear(node, omap_nr_irqs,</span><br><span class="line">			&amp;irq_generic_chip_ops, NULL);</span><br><span class="line"></span><br><span class="line">	omap_irq_soft_reset();</span><br><span class="line"></span><br><span class="line">	ret = omap_alloc_gc_of(domain, omap_irq_base);</span><br><span class="line">	if (ret &lt; 0)</span><br><span class="line">		irq_domain_remove(domain);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在omap_init_irq函数中，首先为irq映射io，接着调用irq_domain_add_liner函数申请其domain和向全局irq_domain链表中添加其domain，并且初始化了domain的ops成员以及根据irq个数为其linear_revmap成员申请空间。该中断控制器的ops成员如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct irq_domain_ops irq_generic_chip_ops = &#123;</span><br><span class="line">	.map	= irq_map_generic_chip,</span><br><span class="line">	.unmap  = irq_unmap_generic_chip,</span><br><span class="line">	.xlate	= irq_domain_xlate_onetwocell,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后通过写寄存器软复位中断控制器。</p>
<p>最后通过omap_alloc_gc_of函数申请并初始化了irq_chip_generic成员。并初始化了irq_chip_generic的irq_chip_type成员以及irq_chip_type成员的irq_chip成员结构，irq_chip结构中有一些列中断chip相关的函数指针，其中有清中断，中断应答，中断屏蔽，中断使能等函数指针。对irq_chip_type类型成员的初始化代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ct = gc-&gt;chip_types;</span><br><span class="line"></span><br><span class="line">ct-&gt;type = IRQ_TYPE_LEVEL_MASK;</span><br><span class="line"></span><br><span class="line">ct-&gt;chip.irq_ack = omap_mask_ack_irq;</span><br><span class="line">ct-&gt;chip.irq_mask = irq_gc_mask_disable_reg;</span><br><span class="line">ct-&gt;chip.irq_unmask = irq_gc_unmask_enable_reg;</span><br><span class="line"></span><br><span class="line">ct-&gt;chip.flags |= IRQCHIP_SKIP_SET_WAKE;</span><br><span class="line"></span><br><span class="line">ct-&gt;regs.enable = INTC_MIR_CLEAR0 + 32 * i;</span><br><span class="line">ct-&gt;regs.disable = INTC_MIR_SET0 + 32 * i;</span><br></pre></td></tr></table></figure>
<p>其中断处理函数注册为handle_level_irq，下面的代码将handle_level_irq函数设置到该中断域gc成员的ct成员的handler，在关联irq_desc的时候会调用到irq_domain的ops中的map函数，将其设置到irq_desc的handle_irq函数指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = irq_alloc_domain_generic_chips(d, 32, 1, &quot;INTC&quot;,</span><br><span class="line">			handle_level_irq, IRQ_NOREQUEST | IRQ_NOPROBE,</span><br><span class="line">			IRQ_LEVEL, 0);</span><br></pre></td></tr></table></figure>
<h3 id="其他中断控制器初始化"><a href="#其他中断控制器初始化" class="headerlink" title="其他中断控制器初始化"></a>其他中断控制器初始化</h3><p>以gpio-omap为例，在gpio-omap的probe函数中，首先申请和初始化irq_chip结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">irqc = devm_kzalloc(dev, sizeof(*irqc), GFP_KERNEL);</span><br><span class="line">if (!irqc)</span><br><span class="line">	return -ENOMEM;</span><br><span class="line"></span><br><span class="line">irqc-&gt;irq_startup = omap_gpio_irq_startup,</span><br><span class="line">irqc-&gt;irq_shutdown = omap_gpio_irq_shutdown,</span><br><span class="line">irqc-&gt;irq_ack = omap_gpio_ack_irq,</span><br><span class="line">irqc-&gt;irq_mask = omap_gpio_mask_irq,</span><br><span class="line">irqc-&gt;irq_unmask = omap_gpio_unmask_irq,</span><br><span class="line">irqc-&gt;irq_set_type = omap_gpio_irq_type,</span><br><span class="line">irqc-&gt;irq_set_wake = omap_gpio_wake_enable,</span><br><span class="line">irqc-&gt;irq_bus_lock = omap_gpio_irq_bus_lock,</span><br><span class="line">irqc-&gt;irq_bus_sync_unlock = gpio_irq_bus_sync_unlock,</span><br><span class="line">irqc-&gt;name = dev_name(&amp;pdev-&gt;dev);</span><br><span class="line">irqc-&gt;flags = IRQCHIP_MASK_ON_SUSPEND;</span><br></pre></td></tr></table></figure>
<p>gpio的资源由gpio_chip结构维护。在probe函数中执行omap_gpio_chip_init函数，在该函数中首先通过执行irq_alloc_descs为该gpio_chip的所有gpio中断申请irq_desc。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">irq_base = irq_alloc_descs(-1, 0, bank-&gt;width, 0);</span><br><span class="line">if (irq_base &lt; 0) &#123;</span><br><span class="line">	dev_err(bank-&gt;chip.parent, &quot;Couldn&apos;t allocate IRQ numbers\n&quot;);</span><br><span class="line">	return -ENODEV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过调用gpiochip_irqchip_add函数为该gpio_chip申请和设置irq_domain结构，将之前申请和初始化的irq_chip也关联到其irq_domain。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = gpiochip_irqchip_add(&amp;bank-&gt;chip, irqc,</span><br><span class="line">			   irq_base, handle_bad_irq,</span><br><span class="line">			   IRQ_TYPE_NONE);</span><br></pre></td></tr></table></figure>
<p>gpiochip_irqchip_add是一个宏，最终调用的函数为_gpiochip_irqchip_add，在该函数中首先为该gpio_chip分配了irq_domain结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpiochip-&gt;irqdomain = irq_domain_add_simple(of_node,</span><br><span class="line">				gpiochip-&gt;ngpio, first_irq,</span><br><span class="line">				&amp;gpiochip_domain_ops, gpiochip);</span><br></pre></td></tr></table></figure>
<p>gpiochip的domain-&gt;ops-&gt;map被设置为gpiochip_domain_ops：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static const struct irq_domain_ops gpiochip_domain_ops = &#123;</span><br><span class="line">	.map	= gpiochip_irq_map,</span><br><span class="line">	.unmap	= gpiochip_irq_unmap,</span><br><span class="line">	/* Virtually all GPIO irqchips are twocell:ed */</span><br><span class="line">	.xlate	= irq_domain_xlate_twocell,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着调用循环调用irq_create_mapping函数，为该gpio_chip里的每一个gpio中断向irq_desc数组中添加项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (offset = 0; offset &lt; gpiochip-&gt;ngpio; offset++) &#123;</span><br><span class="line">	if (!gpiochip_irqchip_irq_valid(gpiochip, offset))</span><br><span class="line">		continue;</span><br><span class="line">	irq_base = irq_create_mapping(gpiochip-&gt;irqdomain, offset);</span><br><span class="line">	if (!irq_base_set) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * Store the base into the gpiochip to be used when</span><br><span class="line">		 * unmapping the irqs.</span><br><span class="line">		 */</span><br><span class="line">		gpiochip-&gt;irq_base = irq_base;</span><br><span class="line">		irq_base_set = true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>irq_create_mapping函数中向irq_desc中添加项的代码如下，该代码路径为<code>kernel/irq/irqdomain.c</code></p>
<p>首先在该gpio_chip的domain中检查该gpio的虚拟中断号是否注册，没有的话向irq_desc中添加该项并得到该项的下标，即虚拟终端号，然后执行irq_domain_associate函数将该虚拟号和硬件中断号的绑定关系存放在该gpio_chip的domain中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* Check if mapping already exists */</span><br><span class="line">virq = irq_find_mapping(domain, hwirq);</span><br><span class="line">if (virq) &#123;</span><br><span class="line">	pr_debug(&quot;-&gt; existing mapping on virq %d\n&quot;, virq);</span><br><span class="line">	return virq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Allocate a virtual interrupt number */</span><br><span class="line">virq = irq_domain_alloc_descs(-1, 1, hwirq, of_node_to_nid(of_node), NULL);</span><br><span class="line">if (virq &lt;= 0) &#123;</span><br><span class="line">	pr_debug(&quot;-&gt; virq allocation failed\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (irq_domain_associate(domain, virq, hwirq)) &#123;</span><br><span class="line">	irq_free_desc(virq);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在irq_domain_associate函数中建立关系的时候，首先通过执行domain-&gt;ops-&gt;map设置该中断的irq_desc中的irq_data的chip_data为该gpio_chip，设置irq_desc的irq_handler为该gpio_chip的irq_handler函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ret = domain-&gt;ops-&gt;map(domain, virq, hwirq);</span><br><span class="line">实现代码为gpiochip_irq_map：</span><br><span class="line">struct gpio_chip *chip = d-&gt;host_data;</span><br><span class="line"></span><br><span class="line">irq_set_chip_data(irq, chip);</span><br><span class="line">/*</span><br><span class="line"> * This lock class tells lockdep that GPIO irqs are in a different</span><br><span class="line"> * category than their parents, so it won&apos;t report false recursion.</span><br><span class="line"> */</span><br><span class="line">irq_set_lockdep_class(irq, chip-&gt;lock_key);</span><br><span class="line">irq_set_chip_and_handler(irq, chip-&gt;irqchip, chip-&gt;irq_handler);</span><br></pre></td></tr></table></figure>
<p>然后直接将该virq添加到domain中的linear_revmap数组中以hwirq为下标的项中，在该domain中记录硬件中断号和虚拟中断号的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">domain-&gt;linear_revmap[hwirq] = virq;</span><br></pre></td></tr></table></figure>
<p>完成domain申请和irq_desc添加后，为其父中断irq注册中断，设置父中断的irq回调函数为omap_gpio_irq_handler。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = devm_request_irq(bank-&gt;chip.parent, bank-&gt;irq,</span><br><span class="line">		       omap_gpio_irq_handler,</span><br><span class="line">		       0, dev_name(bank-&gt;chip.parent), bank);</span><br></pre></td></tr></table></figure>
<p>由于gpio中断控制器是连接到根中断控制器的某个中断上的，所以这里注册的omap_gpio_irq_handler函数就是为根中断控制器的关联中断申请了中断处理函数。</p>
<h3 id="中断系统框架"><a href="#中断系统框架" class="headerlink" title="中断系统框架"></a>中断系统框架</h3><p>在linux内核中，每一个中断都用一个irq_desc结构描述。irq_desc中用一个handle_irq方法进行中断处理，用action链表表示注册在该链表上的处理方法，用irq_data表示硬件相关的数据操作，比如irq_chip，硬件中断号，中断控制器的domain等。</p>
<p>handle_irq一般有两种实现方法，当该irq_desc为一个中断控制器的父中断时，该方法一般实现为分发功能，而且该方法一般由子中断控制器实现，主要功能是根据子中断控制器的状态状态寄存器获取子中断控制器上产生中断并处理之；当irq_desc为一个普通中断时，该方法一般实现过程是调用action列表每一个列表元素的handler函数（该函数为用户真正在申请该中断时注册的处理方法），并清除中断标记。</p>
<p>action列表主要记录了中断申请者的回调函数。当发生中断时，在irq_desc的handle_irq方法执行的时候，会调用每一个action中的handler函数。大部分情况下action列表中只有一个元素，有些情况下会有多个元素，比如一个共享的中断。</p>
<p>irq_data中主要为中断控制器的相关数据。每一个中断控制器都有一个domain结构，该结构用来管理该中断控制器的中断资源以及记录硬件中断号和软件中断号之间的关系。有一个或多个irq_chip结构，向中断核心提供了irq的操作函数列表。</p>
<p>中断处理流程：当cpu被中断时，首先通过根中断控制器的中断状态寄存器得到中断cpu的硬件中断号，然后从根中断控制器的domain结构的linear_revmap数组中得到在irq_desc中记录的中断号，再通过中断号找到irq_desc，并执行irq_desc-&gt;handle_irq函数。如果是普通中断，则在irq_desc-&gt;handle_irq中调用irq_desc中action成员的handler函数。如果是子中断控制器产生的中断，则重复上面的过程处理子中断控制器上的中断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: 获取irq_dest</span><br><span class="line">cond=&gt;condition: 普通中断？</span><br><span class="line">sub1=&gt;subroutine: 分发到子中断控制器</span><br><span class="line">io=&gt;inputoutput: 执行action列表回调并清中断</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">st-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>
<p>中断号和硬件中断号之间的关系：在Linux内核中，用irq_desc类型的结构数组描述中断，该数组的每一个元素都表示一个中断，该数组元素的索引即是该中断的中断号，因此，中断号是唯一的，一个中断号对应一个中断。而硬件中断号是一个中断在某个中断控制器上的描述。因为有多个中断控制器，所以硬件中断号是会重复的。每个中断控制器都有一个irq_domain结构与之对应，在irq_domain中记录了硬件中断号和中断号之间的对应关系。在irq_domain中通过整数数组或基数树记录中断号和硬件中断号之间的关系，最简单的方法是用一个整数数组来记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">domain-&gt;linear_revmap[hwirq] = virq;</span><br></pre></td></tr></table></figure>
<p>可以看出，在linear_revmap数组中，用硬件中断号表示数组的索引值，数组元素为中断号。</p>
<h2 id="四-Linux中断处理过程"><a href="#四-Linux中断处理过程" class="headerlink" title="四.Linux中断处理过程"></a>四.Linux中断处理过程</h2><h3 id="C语言入口函数"><a href="#C语言入口函数" class="headerlink" title="C语言入口函数"></a>C语言入口函数</h3><p>cpu被中断时，先跳转到异常向量表所指定的中断入口执行指令，最终会调用到C语言函数指针接口handle_arch_irq，这个接口由不同芯片的代码设置，一般是在根中断控制器初始化的时候调用set_handle_irq接口设置的，以am335x中断驱动为例，其设置该函数代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_handle_irq(omap_intc_handle_irq);</span><br></pre></td></tr></table></figure>
<h3 id="获取当前中断cpu的中断号"><a href="#获取当前中断cpu的中断号" class="headerlink" title="获取当前中断cpu的中断号"></a>获取当前中断cpu的中断号</h3><p>在omap_intc_handle_irq中首先读取中断控制器的 INTC_SIR_IRQ寄存器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irqnr = intc_readl(INTC_SIR);</span><br></pre></td></tr></table></figure>
<p>接着通过该寄存器0-6位得到当前中断CPU的中断号（由335x芯片手册知该寄存器的0-6位表示当前中断cpu的硬件中断号）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irqnr &amp;= ACTIVEIRQ_MASK;</span><br></pre></td></tr></table></figure>
<h3 id="处理中断"><a href="#处理中断" class="headerlink" title="处理中断"></a>处理中断</h3><p>获取到中断控制器的当前中断号后调用handle_domain_irq函数处理该中断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handle_domain_irq(domain, irqnr, regs);</span><br></pre></td></tr></table></figure>
<p>handle_domain_irq函数调用__handle_domain_irq函数，在该函数中首先通过irq_find_mapping得到对应的软中断号，软硬中断号的对应关系由domain中的linear_revmap数组记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (lookup)</span><br><span class="line">	irq = irq_find_mapping(domain, hwirq);</span><br></pre></td></tr></table></figure>
<p>然后调用generic_handle_irq()函数处理该中断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">generic_handle_irq(irq);</span><br></pre></td></tr></table></figure>
<p>在generic_handle_irq函数中首先通过中断号获取到该中断对应的irq_desc，再通过generic_handle_irq_desc函数处理之</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int generic_handle_irq(unsigned int irq)</span><br><span class="line">&#123;</span><br><span class="line">	struct irq_desc *desc = irq_to_desc(irq);</span><br><span class="line"></span><br><span class="line">	if (!desc)</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	generic_handle_irq_desc(desc);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在generic_handle_irq_desc中执行该irq_desc结构里的handle_irq函数指针对应的函数处理之。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline void generic_handle_irq_desc(struct irq_desc *desc)</span><br><span class="line">&#123;</span><br><span class="line">	desc-&gt;handle_irq(desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根中断控制器handle_irq处理流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void handle_level_irq(struct irq_desc *desc)</span><br><span class="line">&#123;</span><br><span class="line">	raw_spin_lock(&amp;desc-&gt;lock);</span><br><span class="line">	mask_ack_irq(desc);</span><br><span class="line"></span><br><span class="line">	if (!irq_may_run(desc))</span><br><span class="line">		goto out_unlock;</span><br><span class="line"></span><br><span class="line">	desc-&gt;istate &amp;= ~(IRQS_REPLAY | IRQS_WAITING);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If its disabled or no action available</span><br><span class="line">	 * keep it masked and get out of here</span><br><span class="line">	 */</span><br><span class="line">	if (unlikely(!desc-&gt;action || irqd_irq_disabled(&amp;desc-&gt;irq_data))) &#123;</span><br><span class="line">		desc-&gt;istate |= IRQS_PENDING;</span><br><span class="line">		goto out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kstat_incr_irqs_this_cpu(desc);</span><br><span class="line">	handle_irq_event(desc);</span><br><span class="line"></span><br><span class="line">	cond_unmask_irq(desc);</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	raw_spin_unlock(&amp;desc-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的代码可直根中断控制器关联的irq_desc-&gt;handle_irq函数首先会执行mask_ack_irq函数标记和响应中断源，然后调用handle_irq_event函数处理中断，该函数中会遍历action链表并执行其handler函数指针，该函数指针即为用户申请中断设置的中断处理函数。处理完中断后调用cond_unmask_irq函数清中断。由该过程可知道，用户调用申请中断的API申请中断的时候并不需要负责清中断操作。</p>
<p>其他中断控制器的处理函数以omap_gpio的bank中断处理函数为例说明，该函数是在gpio中断初始化的时候，注册的其父中断的中断处理函数（omap-gpio为第二级的中断控制器，其父中断为根中断控制器上的某个中断）。</p>
<p>在omap_gpio_irq_handler函数中，首先读取gpio中断控制器的中断状态寄存器（由335x手册可知，该寄存器的0-31位标识32个gpio中断，某一位的值为1表示该中断被触发），并清除读到的值中未使能的中断对应的位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isr_reg = bank-&gt;base + bank-&gt;regs-&gt;irqstatus;</span><br><span class="line">...</span><br><span class="line">enabled = omap_get_gpio_irqbank_mask(bank);</span><br><span class="line">isr_saved = isr = readl_relaxed(isr_reg) &amp; enabled;</span><br></pre></td></tr></table></figure>
<p>为了不在处理中断过程中错过新中断，在处理中断之前，先清除要处理的边沿触发类型的中断标记。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">omap_disable_gpio_irqbank(bank, isr_saved &amp; ~level_mask);</span><br><span class="line">omap_clear_gpio_irqbank(bank, isr_saved &amp; ~level_mask);</span><br><span class="line">omap_enable_gpio_irqbank(bank, isr_saved &amp; ~level_mask);</span><br></pre></td></tr></table></figure>
<p>接着依次从中断状态寄存器中取出值为1的位，该位在中断状态寄存器中的位置就是该中断的硬件中断号，将该位置用bit变量来记录，记录后清除该位，然后调用通用中断处理函数generic_handle_irq进行中断处理。循环该过程处理中断状态寄存器中所有活动的中断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">while (isr) &#123;</span><br><span class="line">	bit = __ffs(isr);  //取出isr中第一个值被设置的位的位置值</span><br><span class="line">	isr &amp;= ~(BIT(bit)); //清除该位置的bit</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;bank-&gt;lock, lock_flags);</span><br><span class="line">	/*</span><br><span class="line">	 * Some chips can&apos;t respond to both rising and falling</span><br><span class="line">	 * at the same time.  If this irq was requested with</span><br><span class="line">	 * both flags, we need to flip the ICR data for the IRQ</span><br><span class="line">	 * to respond to the IRQ for the opposite direction.</span><br><span class="line">	 * This will be indicated in the bank toggle_mask.</span><br><span class="line">	 */</span><br><span class="line">	if (bank-&gt;toggle_mask &amp; (BIT(bit)))</span><br><span class="line">		omap_toggle_gpio_edge_triggering(bank, bit);</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;bank-&gt;lock, lock_flags);</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;bank-&gt;wa_lock, wa_lock_flags);</span><br><span class="line"></span><br><span class="line">	generic_handle_irq(irq_find_mapping(bank-&gt;chip.irqdomain,</span><br><span class="line">					    bit));</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;bank-&gt;wa_lock,</span><br><span class="line">				   wa_lock_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面例子的场景里，gpio中断控制器没有子中断控制器，所以在这里generic_handle_irq函数最终会调用到用户注册的中断处理函数。</p>
<h2 id="五-在linux中使用中断"><a href="#五-在linux中使用中断" class="headerlink" title="五.在linux中使用中断"></a>五.在linux中使用中断</h2><h3 id="在设备树中描述中断"><a href="#在设备树中描述中断" class="headerlink" title="在设备树中描述中断"></a>在设备树中描述中断</h3><p>以am33xx为例说明，中断描述分为三部分，根中断控制器，子中断控制器，以及普通中断的描述。</p>
<p>根中断控制器必须有interrupt-controller属性，根中断控制器还有reg属性和#interrupt-cells属性。interrupt-controller属性表示该设备节点是一个中断控制器，#interrupt-cells表示其子中断用多少个u32类型的值表示描述中断，reg属性描述根中断控制器的内存映射。在33xx系列芯片中，reg属性用两个u32的值表示，第一个表示中断控制器的基地址，第二个表示大小，基地址和大小可通过33xx用户手册的Memory Map章节获得，335x的中断控制器的地址描述如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Device Name		Start_address(hex)	End_addr(hex)	size	Description</span><br><span class="line">________________________________________________________________________</span><br><span class="line">Interrupt con	0x4820_0000		0x4820_0FFF	4KB		intc registers</span><br><span class="line">troller（INTCPS）</span><br></pre></td></tr></table></figure>
<p>33xx系列的根中断控制器设备树节点描述如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">intc:interrupt-controller@48200000 &#123; /*label:name*/ /*设备树节点名字一般用name@addr表示*/</span><br><span class="line">    compatible = &quot;ti,am33xx-intc&quot;;	/*用来和驱动匹配*/</span><br><span class="line">    interrupt-controller;		/*表示自己是一个中断控制器*/</span><br><span class="line">    #interrupt-cells = &lt;1&gt;;		/*子中断用1个u32类型的值来描述中断*/</span><br><span class="line">    reg = &lt;0x48200000 0x1000&gt;;	/*寄存器地址和长度*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>子中断控制器作为一个中断控制器，也需要interrupt-controller和#interrupt-cells两个属性，还需要一个interrupts属性用来描述自己是中断控制器上的哪个中断，前面看到中断控制器的#interrupt-cells属性值为1，所以在子中断控制器的interrupts属性中，只用一个值来描述，这个值表示根中断控制器上的中断号，该值在33xx系列芯片中，可通过用户手册的interrupts章节的ARM Cortex-A8 Interrupt小节查到，335x的gpio0中断控制器的中断描述如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int number   Acronym/name   Source   Signal Name</span><br><span class="line">---------------------------------------------------</span><br><span class="line">96			GPIOINT0A		GPIO 0		POINTRPEND1</span><br></pre></td></tr></table></figure>
<p>33xx系列GPIO中断控制器设备树节点描述如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gpio0:gpio@44e07000 &#123;</span><br><span class="line">	...</span><br><span class="line">	interrupt-controller;	/*表示自己是一个中断控制器*/</span><br><span class="line">	#interrupt-cells = &lt;2&gt;; /*子中断用2个u32值来描述中断*/</span><br><span class="line">	interrupts = &lt;96&gt;;	/*自己关联在根中断控制器上的中断号为96*/</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他中断节点要描述中断则需要有interrupt-parent和interrupts两个属性，interrupt-parent表示自己关联在哪个中断控制器上，interrupts用来描述该中断。以335x上nand节点为例说明，nand的父中断为gpmc中断控制器，所以其interrupt-parent应该为gpmc，gpmc中断控制器的interrupt-cells的值为2，所以在nand节点中每个中断都用2个u32类型的值表示，这两个值的意义一般需要通过查看内核源码中的文档或者驱动源码中查看，在这里第一个值表示关联在gpmc中断控制器上的中断号，第二个值表示中断类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nand@0,0 &#123;</span><br><span class="line">    ...</span><br><span class="line">    interrupt-parent = &lt;&amp;gpmc&gt;;</span><br><span class="line">    interrupts = &lt;0 IRQ_TYPE_NONE&gt;,&lt;1, IRQ_TYPE_NONE&gt;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在驱动程序中使用中断"><a href="#在驱动程序中使用中断" class="headerlink" title="在驱动程序中使用中断"></a>在驱动程序中使用中断</h3><p>在驱动程序中对中断的使用主要有两部分，一是从设备树解析中断节点或属性，创建中断描述符并获得中断号。二是使用得到的中断。</p>
<p>设备树相关的中断操作接口文件路径为：<code>driver/of/irq.c</code></p>
<p>linux内核提供了一些中断API，定义在include/linux/interrupt.h中，一些常用接口如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static inline int __must_check</span><br><span class="line">request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,</span><br><span class="line">	    const char *name, void *dev)</span><br><span class="line">extern void free_irq(unsigned int, void *);</span><br><span class="line"></span><br><span class="line">static inline int __must_check</span><br><span class="line">devm_request_irq(struct device *dev, unsigned int irq, irq_handler_t handler,</span><br><span class="line">		 unsigned long irqflags, const char *devname, void *dev_id)</span><br><span class="line">extern void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id);</span><br><span class="line"></span><br><span class="line">extern void disable_irq(unsigned int irq);</span><br><span class="line">extern void enable_irq(unsigned int irq);</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/Linux/">Linux</a><a href="/tags/kernel/">kernel</a><a href="/tags/Interrupt/">Interrupt</a></div><div class="post-nav"><a class="pre" href="/2020/02/29/Linux内核设备驱动模型/">Linux内核设备驱动模型</a><a class="next" href="/2019/09/25/Linux内核之看门狗子系统/">Linux内核之看门狗子系统</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  id: window.location.pathname.substring(1,window.location.pathname.length),
  owner: 'geekchenxd',
  repo: 'geekchenxd.github.io',
  oauth: {
    client_id: '00f3259791ebc5b5d412',
    client_secret: 'd88056bc0050337d5767e26f8d228f526ed7687d',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://www.chenxd.xyz"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel/">Kernel</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/qemu/">qemu</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/watchdog/" style="font-size: 15px;">watchdog</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/subsystem/" style="font-size: 15px;">subsystem</a> <a href="/tags/initcall/" style="font-size: 15px;">initcall</a> <a href="/tags/notification/" style="font-size: 15px;">notification</a> <a href="/tags/file-system/" style="font-size: 15px;">file_system</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/Debug/" style="font-size: 15px;">Debug</a> <a href="/tags/arm/" style="font-size: 15px;">arm</a> <a href="/tags/dtb/" style="font-size: 15px;">dtb</a> <a href="/tags/dts/" style="font-size: 15px;">dts</a> <a href="/tags/Interrupt/" style="font-size: 15px;">Interrupt</a> <a href="/tags/usb/" style="font-size: 15px;">usb</a> <a href="/tags/device-driver/" style="font-size: 15px;">device driver</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/06/06/ARM-LINUX根文件系统移植/">ARM-LINUX根文件系统移植</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/05/Linux内核调试之KGDB/">Linux内核调试之KGDB</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/Linux内核通知链/">Linux内核通知链</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/Qemu虚拟Arm开发板/">Qemu虚拟Arm开发板</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/Linux内核设备驱动模型/">Linux内核设备驱动模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/26/ARM-LINUX中断系统/">ARM-LINUX中断系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/25/Linux内核之看门狗子系统/">Linux内核之看门狗子系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/24/Linux内核之虚拟文件系统/">Linux内核之虚拟文件系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/28/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/09/Linux内核usb子系统/">Linux内核usb子系统</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.github.com" title="github" target="_blank">github</a><ul></ul><a href="http://www.kernel.org" title="linux kernel" target="_blank">linux kernel</a><ul></ul><a href="http://www.combatpress.com/" title="Combat Press" target="_blank">Combat Press</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Evil Code.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>