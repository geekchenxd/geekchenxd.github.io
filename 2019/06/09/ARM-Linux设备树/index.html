<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Code controls all the hardware"><title>ARM-Linux设备树 | Evil Code</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ARM-Linux设备树</h1><a id="logo" href="/.">Evil Code</a><p class="description">Coding Change The World</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ARM-Linux设备树</h1><div class="post-meta">Jun 9, 2019<span> | </span><span class="category"><a href="/categories/Kernel/">Kernel</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一-设备树是什么"><span class="toc-number">1.</span> <span class="toc-text">一.设备树是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-设备树的概念"><span class="toc-number">1.1.</span> <span class="toc-text">1.设备树的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-使用设备树的意义"><span class="toc-number">1.2.</span> <span class="toc-text">2.使用设备树的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-设备树文件"><span class="toc-number">1.3.</span> <span class="toc-text">3.设备树文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二-DTS-Devicetree-Source-的格式"><span class="toc-number">2.</span> <span class="toc-text">二.DTS(Devicetree Source)的格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-DTS文件布局（Version-1）"><span class="toc-number">2.1.</span> <span class="toc-text">1.DTS文件布局（Version 1）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Labels"><span class="toc-number">2.2.</span> <span class="toc-text">2.Labels</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-节点和属性的定义"><span class="toc-number">2.3.</span> <span class="toc-text">3.节点和属性的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三-DTB-Devicetree-Blob-的格式"><span class="toc-number">3.</span> <span class="toc-text">三.DTB(Devicetree Blob)的格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-设备树文件的结构和布局"><span class="toc-number">3.1.</span> <span class="toc-text">1.设备树文件的结构和布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-struct-fdt-header"><span class="toc-number">3.2.</span> <span class="toc-text">2.struct fdt_header</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Memory-Reservation-block"><span class="toc-number">3.3.</span> <span class="toc-text">2.Memory Reservation block</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Structure-Block"><span class="toc-number">3.4.</span> <span class="toc-text">3.Structure Block</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Strings-Block"><span class="toc-number">3.5.</span> <span class="toc-text">4.Strings Block</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四-uboot如何将设备树传递给内核"><span class="toc-number">4.</span> <span class="toc-text">四.uboot如何将设备树传递给内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五-Linux内核如何处理设备树"><span class="toc-number">5.</span> <span class="toc-text">五.Linux内核如何处理设备树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-setup-machine-fdt"><span class="toc-number">5.1.</span> <span class="toc-text">1.setup_machine_fdt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-设备树展开为device-node"><span class="toc-number">5.2.</span> <span class="toc-text">2.设备树展开为device_node</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Device-node如何转换成平台设备"><span class="toc-number">5.3.</span> <span class="toc-text">3.Device_node如何转换成平台设备</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六-内核中设备树操作接口"><span class="toc-number">6.</span> <span class="toc-text">六.内核中设备树操作接口</span></a></li></ol></div></div><div class="post-content"><h3 id="一-设备树是什么"><a href="#一-设备树是什么" class="headerlink" title="一.设备树是什么"></a>一.设备树是什么</h3><h4 id="1-设备树的概念"><a href="#1-设备树的概念" class="headerlink" title="1.设备树的概念"></a>1.设备树的概念</h4><p>​    设备树是由DTSpec规范定义的一个描述系统硬件的数据结构。加载程序加载一个设备树到客户端程序的内存中并且传递指向该设备树的指针给客户端程序。客户端程序通过设备树指针获取系统硬件参数。</p>
<h4 id="2-使用设备树的意义"><a href="#2-使用设备树的意义" class="headerlink" title="2.使用设备树的意义"></a>2.使用设备树的意义</h4><p>​    由于各个芯片厂家的硬件平台差异，导致在linux内核平台架构目录下充斥着大量的厂家平台代码，导致内核冗余代码多，移植复杂等诸多问题，设备树的引入使得内核和硬件资源的描述相对独立。精简了平台代码，简化了驱动开发和移植。</p>
<h4 id="3-设备树文件"><a href="#3-设备树文件" class="headerlink" title="3.设备树文件"></a>3.设备树文件</h4><p>​    设备树有设备树源码(dts和dtsi)文件和二进制的设备树(.dtb)文件。设备树以二进制的形式加载到内存中供客户端程序使用。设备树的二进制文件由设备树源码文件通过设备树编译器(dtc)编译而成。符合DTSpec的设备树描述那些系统中不能被客户端程序动态检测到的设备信息。比如，PCI架构允许客户端检测附加设备，因此可能不需要描述PCI设备的设备树节点，然而需要一个描述系统中的PCI主控制器的设备节点如果该控制器不能被检测到。以下的例子描述了一个简单的具有platform type，cpu，memory，和一个uart的设备树，它基本可以启动一个简单的操作系统。该设备树的每个节点的属性和值都在节点内部。</p>
<p><img src="/.xyz//2019-05-11_151014.png" alt="一个简单的设备树文件"></p>
<h3 id="二-DTS-Devicetree-Source-的格式"><a href="#二-DTS-Devicetree-Source-的格式" class="headerlink" title="二.DTS(Devicetree Source)的格式"></a>二.DTS(Devicetree Source)的格式</h3><h4 id="1-DTS文件布局（Version-1）"><a href="#1-DTS文件布局（Version-1）" class="headerlink" title="1.DTS文件布局（Version 1）"></a>1.DTS文件布局（Version 1）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">[memory reservations]</span><br><span class="line">	/&#123;</span><br><span class="line">        [property definitions]</span><br><span class="line">        [child nodes]</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>/dts-v1/用来描述设备树的版本为V1(设备树没有指定版本的这一行的话，设备树将默认按V0版本编译，除了其他小的但不兼容的更改外，该版本对整数使用不同的格式。)。</p>
<p>Memory reservations定义了设备树中保留内存表的入口，格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/memreserve/ &lt;address&gt; &lt;length&gt;</span><br></pre></td></tr></table></figure>
<p>/{}；定义了设备树的根节点。</p>
<p>设备树支持C风格(/<em> </em>/)和C++风格(//)的注释方式。</p>
<p>设备树可以包含dtsi文件或头文件，dtsi文件本身也可以包含其他文件。</p>
<h4 id="2-Labels"><a href="#2-Labels" class="headerlink" title="2.Labels"></a>2.Labels</h4><p>​    设备树源文件的任何节点或属性值都支持label，使用label代替绝对路径或phandle引用节点或属性值可自动在dtb中生成phandle。label名字长度为1-31个字符，label名以下划线，大写字母或小写字母开头，由数字，下划线，大小写字母组成。label的使用方法如下。</p>
<p>2.1.为节点定义label：在节点名前面加上label名字和’:’即可。</p>
<p>2.2.通过label引用节点或属性值：在label名前加上&amp;即可。</p>
<h4 id="3-节点和属性的定义"><a href="#3-节点和属性的定义" class="headerlink" title="3.节点和属性的定义"></a>3.节点和属性的定义</h4><p>节点由节点名和单元地址定义，并跟一组花括号表示节点的开始和结束，节点名之前可以定义label。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[label:] node-name[@unit-address] &#123;</span><br><span class="line">    [properties definitions]</span><br><span class="line">    [child nodes]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果一个节点中同时有节点的属性和子节点的话，应该先定义属性，然后是子节点。</p>
<p>可以删除前面定义的节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">delete</span>-node/ node-name;</span><br><span class="line">/<span class="keyword">delete</span>-node/ &amp;label;</span><br></pre></td></tr></table></figure>
<p>属性定义为属性名和值的键值对，格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[label:] property-name = value;</span><br></pre></td></tr></table></figure>
<p>属性值长度为0的属性定义格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[label:] property-name;</span><br></pre></td></tr></table></figure>
<p>之前定义的属性可以被删除：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">delete</span>-property/ property-name;</span><br></pre></td></tr></table></figure>
<p>属性的值可以是32位整数或null结尾的字符串或者字节串的数组，也可以是这些类型的组合。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interrupts = &lt;<span class="number">17</span> <span class="number">0xc</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>值可以用括号内的算术、位或逻辑表达式表示。支持的运算符如下：</p>
<p>算术运算符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+，-，*，/</span><br></pre></td></tr></table></figure>
<p>位运算符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;，|，^, ~，&lt;&lt;, &gt;&gt;</span><br></pre></td></tr></table></figure>
<p>逻辑运算符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;, ||, !</span><br></pre></td></tr></table></figure>
<p>关系运算符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;, &gt;, &lt;=, &gt;=, ==, !=</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ternary operators</span><br><span class="line">?: (condition ? value_if_true : value_if_false)</span><br></pre></td></tr></table></figure>
<p>一个64bit的值用两个32bit的cells表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock-frequency = &lt;<span class="number">0x00000001</span> <span class="number">0x00000000</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>用双引号表示字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compatible = <span class="string">"simple-bus"</span>;</span><br></pre></td></tr></table></figure>
<p>字节串用方括号[]括起来，每个字节由两个十六进制数字表示。每个字节之间的空格是可选的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local-mac-address = [<span class="number">00</span> <span class="number">00</span> <span class="number">12</span> <span class="number">34</span> <span class="number">56</span> <span class="number">78</span>];</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local-mac-address = [<span class="number">000012345678</span>];</span><br></pre></td></tr></table></figure>
<p>属性有多个值的时候用逗号分开：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compatible = <span class="string">"ns16550"</span>, <span class="string">"ns8250"</span>;</span><br><span class="line">example = &lt;<span class="number">0xf00f0000</span> <span class="number">19</span>&gt;, <span class="string">"a strange property format"</span>;</span><br></pre></td></tr></table></figure>
<p>在一个节点属性值的cell数组中引用另一个节点将会被扩展为该节点的phandle。可以通过&amp;加上节点的label引用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interrupt-parent = &lt; &amp;mpic &gt;;</span><br></pre></td></tr></table></figure>
<p>也可以通过&amp;加上一个用花括号括起来的绝对路径引用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interrupt-parent = &lt; &amp;&#123;/soc/interrupt-controller@<span class="number">40000</span>&#125; &gt;;</span><br></pre></td></tr></table></figure>
<p>不在cell数组中的引用，将会扩展为该节点的绝对路径：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethernet0 = &amp;EMAC0;</span><br></pre></td></tr></table></figure>
<p>Labels也可能在属性值的某个成员前或后，或者cell数组里面的cell之间，或者字节串的字节之间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg = reglabel: &lt;<span class="number">0</span> sizelabel: <span class="number">0x1000000</span>&gt;;</span><br><span class="line">prop = [ab cd ef byte4: <span class="number">00</span> ff fe];</span><br><span class="line">str = start: <span class="string">"string value"</span> end: ;</span><br></pre></td></tr></table></figure>
<h3 id="三-DTB-Devicetree-Blob-的格式"><a href="#三-DTB-Devicetree-Blob-的格式" class="headerlink" title="三.DTB(Devicetree Blob)的格式"></a>三.DTB(Devicetree Blob)的格式</h3><h4 id="1-设备树文件的结构和布局"><a href="#1-设备树文件的结构和布局" class="headerlink" title="1.设备树文件的结构和布局"></a>1.设备树文件的结构和布局</h4><p><img src="/.xyz//2019-05-11_154510.png" alt="设备树文件布局"></p>
<h4 id="2-struct-fdt-header"><a href="#2-struct-fdt-header" class="headerlink" title="2.struct fdt_header"></a>2.struct fdt_header</h4><p>扁平设备树的头部结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_header</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> magic;</span><br><span class="line">	<span class="keyword">uint32_t</span> totalsize;</span><br><span class="line">	<span class="keyword">uint32_t</span> off_dt_struct;</span><br><span class="line">	<span class="keyword">uint32_t</span> off_dt_strings;</span><br><span class="line">	<span class="keyword">uint32_t</span> off_mem_rsvmap;</span><br><span class="line">	<span class="keyword">uint32_t</span> version;</span><br><span class="line">	<span class="keyword">uint32_t</span> last_comp_version;</span><br><span class="line">	<span class="keyword">uint32_t</span> boot_cpuid_phys;</span><br><span class="line">	<span class="keyword">uint32_t</span> size_dt_strings;</span><br><span class="line">	<span class="keyword">uint32_t</span> size_dt_struct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>magic</strong>：0xd00dfeed （大端格式）</p>
<p><strong>totalsize</strong>：设备树数据结构总大小的字节数。包括设备树结构的所有段： the header, the memory reservation block, structure block and strings block, as well as any free space gaps between the blocks or after the final block。</p>
<p><strong>off_dt_struct</strong>：structure block相对于fdt_header起始地址的偏移。</p>
<p><strong>off_dt_strings</strong>: strings block相对于ftd_header起始地址的偏移。</p>
<p><strong>off_mem_rsvmap</strong>：    memory reservation block相对于fdt_header起始地址的偏移。</p>
<p><strong>version</strong>:    设备树数据结构的版本。</p>
<p><strong>last_comp_version</strong>：当前使用的设备树版本能向后兼容的最低版本。</p>
<p><strong>boot_cpuid_phys</strong>：系统启动cpu的物理ID，与设备树中cpu节点reg属性给出的物理ID一致。</p>
<p><strong>size_dt_strings</strong>：设备树中strings block 的大小字节数。</p>
<p><strong>size_dt_struct</strong>：设备树中structure block段的大小字节数。</p>
<h4 id="2-Memory-Reservation-block"><a href="#2-Memory-Reservation-block" class="headerlink" title="2.Memory Reservation block"></a>2.Memory Reservation block</h4><p>​    描述了一组物理内存的保留区域，正常情况下这块内存区域将不被客户端程序使用。除非加载程序的其他信息明确说明需要访问，客户端程序才可能以指定的方式访问。内存预留在设备树中的格式如下：</p>
<p>Memory reservation block由两个64大端位整数组成的一对数据组成的链表组成。每一对都通过下面的C结构表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_reserve_entry</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint64_t</span> address;</span><br><span class="line">	<span class="keyword">uint64_t</span> size</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每一对都给出了保留内存区域的物理地址和大小，给出的区域不能和其他区域重复。内存保留块的链表以一个地址和大小都为0的数据对节点结束。每一个数据对的address和size变量总是64位的，在32位cpu中，高32位被忽略。内存保留块相对dtb起始地址的偏移地址应该是8字节对齐的。</p>
<h4 id="3-Structure-Block"><a href="#3-Structure-Block" class="headerlink" title="3.Structure Block"></a>3.Structure Block</h4><p>​    结构块表示了设备树本身的结构和内容，它由一系列带数据的令牌组成，呈线性树结构。每个令牌都在结构块中，因此结构块相对dtb起始地址的偏移地址应该以4字节对齐。</p>
<p>结构块的结构：</p>
<p>结构块由一系列以一个32位大端整数表示的令牌开始的段构成，有些令牌后面跟着一段用一个令牌标识结束的附加数据。每一个令牌都是以32位宽度的，因此一个令牌区域除了令牌的值，剩余部分用0x0填充。</p>
<p><strong>5种令牌类型如下：</strong></p>
<p>FDT_BEGIN_NODE (0x00000001)，节点开始的令牌，后面应该跟着节点名作为附加数据。名字是一个以null结束的字符串，如果有地址的话名字应该包含地址。如果有必要对齐的话，名字后面应该填充0值，然后是下一个令牌(除了FDT_END令牌)。</p>
<p>FDT_END_NODE(0x00000002)，节点结束令牌，该令牌没有附加数据，所以它后面紧跟着下一个令牌(除了FDT_PROP令牌).</p>
<p>FDT_PROP(0x00000003)，属性开始的令牌，它后面应该跟着描述属性的附加数据。附加数据首先由属性的长度和名字组成，用以下的C结构表示：(32位大端整数)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> len;</span><br><span class="line">	<span class="keyword">uint32_t</span> nameoff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>len变量表示属性的值的长度，该长度可能为0，表示是一个空属性。</p>
<p>nameoff表示属性的名字(null结束的字符串)在string block中的偏移值。</p>
<p>紧跟着这个结构的是表示该属性的value的字符串，长度为结构中的len。然后是按照32位对齐方式补0，再接着就是下一个令牌(除了FDT_END)。</p>
<p>FDT_NOP (0x00000004)，这个令牌在解析设备树时会被忽略。该令牌没有附加数据；所以它后面紧跟着其他任何有效令牌。可以通过使用该token重写某个属性或者节点，达到不移动其他段就可以删除该属性或节点的目的。</p>
<p>FDT_END (0x00000009)，struct block结束的令牌。设备树中只有一个FDT_END，并且FDT_END令牌是struct block的最后一个令牌。该令牌没有附加数据，因此其后所跟的字节相对struct block起始地址的偏移值等于struct fdt_header中size_dt_struct变量的值。</p>
<p>树结构：设备树结构是一个线性树，每一个节点都以FDT_BEGIN_NODE令牌开始，并且以FDT_END_NODE令牌结束。节点的属性或者子节点在FDT_END_NODE之前表示，因此，这些子节点的FDT开始令牌和FDT结束令牌嵌套在父节点的开始和结束令牌中。struct block作为一个整体，由一个根节点(其他节点都嵌套在根节点中)和FDT_END结束。而每一个节点由下面的部分组成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">• (optionally) any number of FDT_NOP tokens</span><br><span class="line">• FDT_BEGIN_NODE token</span><br><span class="line">– The node’s name as a null-terminated <span class="built_in">string</span></span><br><span class="line">– [zeroed padding bytes to align to a <span class="number">4</span>-byte boundary]</span><br><span class="line">• For each property of the node:</span><br><span class="line">– (optionally) any number of FDT_NOP tokens</span><br><span class="line">– FDT_PROP token</span><br><span class="line">*</span><br><span class="line">property information</span><br><span class="line">*</span><br><span class="line">[zeroed padding bytes to align to a <span class="number">4</span>-byte boundary]</span><br><span class="line">• Representations of all child nodes in <span class="keyword">this</span> format</span><br><span class="line">• (optionally) any number of FDT_NOP tokens</span><br><span class="line">• FDT_END_NODE token</span><br></pre></td></tr></table></figure>
<h4 id="4-Strings-Block"><a href="#4-Strings-Block" class="headerlink" title="4.Strings Block"></a>4.Strings Block</h4><p>​    Strings Block包含设备树中所有属性的名字的字符串。这些以null结尾的字符串简单的连接在一起，通过structure block中的偏移值引用。Strings Block没有字节对齐，并可能出现在相对DTB开始偏移地址的任何偏移处。</p>
<h3 id="四-uboot如何将设备树传递给内核"><a href="#四-uboot如何将设备树传递给内核" class="headerlink" title="四.uboot如何将设备树传递给内核"></a>四.uboot如何将设备树传递给内核</h3><p>bootloader通过设置r0,r1,r2三个寄存器来给内核传递参数</p>
<p>r0一般设置为0；</p>
<p>r1一般设置为machine id，当内核使用设备树时该参数未使用。</p>
<p>r2一般设置为ATAGS或者fdt的首地址</p>
<p>在内核启动代码head.S和head-common.S中将r1寄存器的值赋给变量__machine_arch_type,将r2寄存器的值赋给了atags_pointer变量。</p>
<p>在setup_arch函数中调用<strong>setup_machine_fdt时将</strong>atags_pointer（设备树首地址）传入。</p>
<h3 id="五-Linux内核如何处理设备树"><a href="#五-Linux内核如何处理设备树" class="headerlink" title="五.Linux内核如何处理设备树"></a>五.Linux内核如何处理设备树</h3><p>在arch/arm/kernel/setup.c文件中的setup_arch函数中，通过调用两个函数分两个步骤来解析设备树。</p>
<h4 id="1-setup-machine-fdt"><a href="#1-setup-machine-fdt" class="headerlink" title="1.setup_machine_fdt"></a>1.setup_machine_fdt</h4><p>​    通过setup_machine_fdt主要完成了设备树的检查，machine_desc的匹配，命令行参数的解析，根节点dt_root_address_cells和dt_root_size_cells的设置以及内存添加。以下是简单代码流程分析。</p>
<p>在setup_arch函数中调用setup_machine_fdt时传入了设备树的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdesc = setup_machine_fdt(__atags_pointer);</span><br></pre></td></tr></table></figure>
<p>setup_machine_fdt函数主要完成以下工作：</p>
<p>1.检查设备树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dt_phys || !early_init_dt_verify(phys_to_virt(dt_phys)))</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>2.通过设备树的根节点的compatible属性匹配machine_desc。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);</span><br></pre></td></tr></table></figure>
<p>3.调用early_init_dt_scan_nodes函数完成设置boot_command_line，设置dt_root_size_cells和dt_root_address_cells，添加内存的操作。命令行参数通过扫描设备树的chosen节点获得，dt_root_size_cells和dt_root_address_cells是两个全局变量，在设备树解析的过程中都会用到。从设备树解析出内存信息后通过调用memblock_add函数添加内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">early_init_dt_scan_nodes</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Retrieve various information from the /chosen node */</span></span><br><span class="line">	rc = of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);</span><br><span class="line">	<span class="keyword">if</span> (!rc)</span><br><span class="line">		pr_warn(<span class="string">"No chosen node found, continuing without\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize &#123;size,address&#125;-cells info */</span></span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_root, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup memory, calling early_init_dt_add_memory_arch */</span></span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_memory, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-设备树展开为device-node"><a href="#2-设备树展开为device-node" class="headerlink" title="2.设备树展开为device_node"></a>2.设备树展开为device_node</h4><p>​    通过调用unflatten_device_tree函数将设备树展开为一个device_node类型的树，就是将所有节点从设备树中解析出来并添加到全局链表of_root上。设置系统chosen节点。解析aliases节点并将aliases的属性(其他节点，aliases节点中主要是一些节点的别名和引用)添加到aliases_lookup链表中，以供后续使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *unflatten_device_tree - create tree of device_nodes from flat blob</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *unflattens the device-tree passed by the firmware, creating the</span></span><br><span class="line"><span class="comment"> *tree of struct device_node. It also fills the "name" and "type"</span></span><br><span class="line"><span class="comment"> *pointers of the nodes so the normal device-tree walking functions</span></span><br><span class="line"><span class="comment"> *can be used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">unflatten_device_tree</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __unflatten_device_tree(initial_boot_params, <span class="literal">NULL</span>, &amp;of_root,</span><br><span class="line">                early_init_dt_alloc_memory_arch, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */</span></span><br><span class="line">    of_alias_scan(early_init_dt_alloc_memory_arch);</span><br><span class="line"></span><br><span class="line">    unittest_unflatten_overlay_base();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-Device-node如何转换成平台设备"><a href="#3-Device-node如何转换成平台设备" class="headerlink" title="3.Device_node如何转换成平台设备"></a>3.Device_node如何转换成平台设备</h4><p>​    设备树解析后要被平台驱动使用，就需要将设备树device_node转换为平台设备platform_device，在系统初始化调用里设置了如下入口，该函数通过调用其他接口为满足条件的device_node创建了平台设备，并设置平台设备的of_node指针为device_node，并将平台设备添加到平台链表中，这样在添加平台驱动的时候就可以匹配到平台设备，并调用相应的probe回调，进而在probe回调中反过来使用平台设备的of_node。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">of_platform_default_populate_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!of_have_populated_dt())</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Handle certain compatibles explicitly, since we don't want to create</span></span><br><span class="line"><span class="comment">        platform_devices for every node in /reserved-memory with a</span></span><br><span class="line"><span class="comment">        "compatible",</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    for_each_matching_node(node, reserved_mem_matches)</span><br><span class="line">    of_platform_device_create(node, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    node = of_find_node_by_path(<span class="string">"/firmware"</span>);</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        of_platform_populate(node, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        of_node_put(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Populate everything else. */</span></span><br><span class="line">    of_platform_default_populate(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">arch_initcall_sync(of_platform_default_populate_init);</span><br></pre></td></tr></table></figure>
<h3 id="六-内核中设备树操作接口"><a href="#六-内核中设备树操作接口" class="headerlink" title="六.内核中设备树操作接口"></a>六.内核中设备树操作接口</h3><p>在内核目录的/drivers/of/目录下是设备树相关的接口文件,里面有各种设备树读取或修改设备,属性,等的接口函数,在内核模块中可以包含相应头文件并利用这些接口操作设备树。</p>
</div><div class="tags"><a href="/tags/Linux/">Linux</a><a href="/tags/kernel/">kernel</a><a href="/tags/dtb/">dtb</a><a href="/tags/dts/">dts</a></div><div class="post-nav"><a class="pre" href="/2019/06/09/Linux内核initcall过程/">Linux内核initcall过程</a><a class="next" href="/2019/04/09/Docker使用小记/">Docker使用小记</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  id: window.location.pathname.substring(1,window.location.pathname.length),
  owner: 'geekchenxd',
  repo: 'geekchenxd.github.io',
  oauth: {
    client_id: '00f3259791ebc5b5d412',
    client_secret: 'd88056bc0050337d5767e26f8d228f526ed7687d',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://www.chenxd.xyz"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel/">Kernel</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/qemu/">qemu</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/arm/" style="font-size: 15px;">arm</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/subsystem/" style="font-size: 15px;">subsystem</a> <a href="/tags/initcall/" style="font-size: 15px;">initcall</a> <a href="/tags/notification/" style="font-size: 15px;">notification</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/watchdog/" style="font-size: 15px;">watchdog</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/dtb/" style="font-size: 15px;">dtb</a> <a href="/tags/dts/" style="font-size: 15px;">dts</a> <a href="/tags/file-system/" style="font-size: 15px;">file_system</a> <a href="/tags/Interrupt/" style="font-size: 15px;">Interrupt</a> <a href="/tags/usb/" style="font-size: 15px;">usb</a> <a href="/tags/device-driver/" style="font-size: 15px;">device driver</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/Qemu虚拟Arm开发板/">Qemu虚拟Arm开发板</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/Linux内核设备驱动模型/">Linux内核设备驱动模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/Linux内核通知链/">Linux内核通知链</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/26/ARM-LINUX中断系统/">ARM-LINUX中断系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/25/Linux内核之看门狗子系统/">Linux内核之看门狗子系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/24/Linux内核之虚拟文件系统/">Linux内核之虚拟文件系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/28/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/09/Linux内核usb子系统/">Linux内核usb子系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/09/Linux内核initcall过程/">Linux内核initcall过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/09/ARM-Linux设备树/">ARM-Linux设备树</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.github.com" title="github" target="_blank">github</a><ul></ul><a href="http://www.kernel.org" title="linux kernel" target="_blank">linux kernel</a><ul></ul><a href="http://www.combatpress.com/" title="Combat Press" target="_blank">Combat Press</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Evil Code.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>