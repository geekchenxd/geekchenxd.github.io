<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Code controls all the hardware"><title>Linux内核usb子系统 | Evil Code</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux内核usb子系统</h1><a id="logo" href="/.">Evil Code</a><p class="description">Coding Change The World</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux内核usb子系统</h1><div class="post-meta">Jun 9, 2019<span> | </span><span class="category"><a href="/categories/Kernel/">Kernel</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#USB设备结构"><span class="toc-number">1.</span> <span class="toc-text">USB设备结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USB设备类型"><span class="toc-number">2.</span> <span class="toc-text">USB设备类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#usb设备"><span class="toc-number">2.1.</span> <span class="toc-text">usb设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usb接口"><span class="toc-number">2.2.</span> <span class="toc-text">usb接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USB驱动类型"><span class="toc-number">3.</span> <span class="toc-text">USB驱动类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#驱动结构"><span class="toc-number">3.1.</span> <span class="toc-text">驱动结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#驱动类型的区分"><span class="toc-number">3.2.</span> <span class="toc-text">驱动类型的区分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#驱动注册"><span class="toc-number">3.3.</span> <span class="toc-text">驱动注册</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USB设备驱动模型"><span class="toc-number">4.</span> <span class="toc-text">USB设备驱动模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-number">4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USB总线"><span class="toc-number">4.2.</span> <span class="toc-text">USB总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usb设备-1"><span class="toc-number">4.3.</span> <span class="toc-text">usb设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usb驱动"><span class="toc-number">4.4.</span> <span class="toc-text">usb驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sysfs"><span class="toc-number">4.5.</span> <span class="toc-text">sysfs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#generic驱动"><span class="toc-number">4.6.</span> <span class="toc-text">generic驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hub驱动"><span class="toc-number">4.7.</span> <span class="toc-text">hub驱动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USB控制器驱动"><span class="toc-number">5.</span> <span class="toc-text">USB控制器驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#usb主控制器（hcd）"><span class="toc-number">5.1.</span> <span class="toc-text">usb主控制器（hcd）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制器驱动（hc）"><span class="toc-number">5.2.</span> <span class="toc-text">控制器驱动（hc）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源代码分析"><span class="toc-number">6.</span> <span class="toc-text">源代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#USB子系统初始化"><span class="toc-number">6.1.</span> <span class="toc-text">USB子系统初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USB总线匹配方法"><span class="toc-number">6.2.</span> <span class="toc-text">USB总线匹配方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USB-通用驱动"><span class="toc-number">6.3.</span> <span class="toc-text">USB 通用驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USB-HUB驱动"><span class="toc-number">6.4.</span> <span class="toc-text">USB HUB驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USB-HCD注册"><span class="toc-number">6.5.</span> <span class="toc-text">USB_HCD注册</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usb驱动编写流程"><span class="toc-number">7.</span> <span class="toc-text">usb驱动编写流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义驱动"><span class="toc-number">7.1.</span> <span class="toc-text">定义驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册驱动"><span class="toc-number">7.2.</span> <span class="toc-text">注册驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#驱动功能"><span class="toc-number">7.3.</span> <span class="toc-text">驱动功能</span></a></li></ol></li></ol></div></div><div class="post-content"><p>了解USB子系统框架是编写和调试usb设备驱动的必要程序，了解USB子系统框架的前提基础知识是linux内核设备驱动模型。</p>
<h2 id="USB设备结构"><a href="#USB设备结构" class="headerlink" title="USB设备结构"></a>USB设备结构</h2><p>在usb规范中，一个usb设备通过一些层级结构的描述符来描述。在linux内核中，通过usb_device结构来表示一个usb设备，通常一个usb设备有一个设备描述符，一个或多个配置描述符，以及一个或多个接口描述符。设备描述符用来描述设备的信息，包含厂家ID，产品ID等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* USB_DT_DEVICE: Device descriptor */</span><br><span class="line">struct usb_device_descriptor &#123;</span><br><span class="line">        __u8  bLength;</span><br><span class="line">        __u8  bDescriptorType;</span><br><span class="line"></span><br><span class="line">        __le16 bcdUSB;</span><br><span class="line">        __u8  bDeviceClass;</span><br><span class="line">        __u8  bDeviceSubClass;</span><br><span class="line">        __u8  bDeviceProtocol;</span><br><span class="line">        __u8  bMaxPacketSize0;</span><br><span class="line">        __le16 idVendor;</span><br><span class="line">        __le16 idProduct;</span><br><span class="line">        __le16 bcdDevice;</span><br><span class="line">        __u8  iManufacturer;</span><br><span class="line">        __u8  iProduct;</span><br><span class="line">        __u8  iSerialNumber;</span><br><span class="line">        __u8  bNumConfigurations;</span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure>
<p>在设备描述符中同时通过bNumConfigurations成员来描述该设备有多少个配置描述符。</p>
<p>在linux内核中，配置描述符和接口描述符用usb_host_config结构来表示，在设备描述符中bNumConfigurations的值为多少就有多少个usb_host_config，usb_host_config中包含了usb设备的配置描述符，以及接口描述符。</p>
<p>usb设备的配置描述符用usb_config_descriptor结构来表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct usb_config_descriptor &#123;</span><br><span class="line">        __u8  bLength;</span><br><span class="line">        __u8  bDescriptorType;</span><br><span class="line"></span><br><span class="line">        __le16 wTotalLength;</span><br><span class="line">        __u8  bNumInterfaces;</span><br><span class="line">        __u8  bConfigurationValue;</span><br><span class="line">        __u8  iConfiguration;</span><br><span class="line">        __u8  bmAttributes;</span><br><span class="line">        __u8  bMaxPower;</span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure>
<p>在配置描述符中通过bNumInterfaces成员来描述该配置描述符包含几个接口描述符。在Linux内核中用usb_interface 结构来描述一个接口设备，配置描述符中的bNumInterfaces的值为多少就有多少个usb_interface。linux内核中用usb_host_interface结构表示接口描述，在该结构中包含了该接口的接口描述符，usb_host_interface结构位于usb_interface结构中。接口描述符定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* USB_DT_INTERFACE: Interface descriptor */</span><br><span class="line">struct usb_interface_descriptor &#123;</span><br><span class="line">        __u8  bLength;</span><br><span class="line">        __u8  bDescriptorType;</span><br><span class="line"></span><br><span class="line">        __u8  bInterfaceNumber;</span><br><span class="line">        __u8  bAlternateSetting;</span><br><span class="line">        __u8  bNumEndpoints;</span><br><span class="line">        __u8  bInterfaceClass;</span><br><span class="line">        __u8  bInterfaceSubClass;</span><br><span class="line">        __u8  bInterfaceProtocol;</span><br><span class="line">        __u8  iInterface;</span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure>
<h2 id="USB设备类型"><a href="#USB设备类型" class="headerlink" title="USB设备类型"></a>USB设备类型</h2><h3 id="usb设备"><a href="#usb设备" class="headerlink" title="usb设备"></a>usb设备</h3><p>usb设备用usb_device结构来表示，它表示一个物理的usb设备。</p>
<p>通过下面的接口判断是否是usb设备：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline int is_usb_device(const struct device *dev)</span><br></pre></td></tr></table></figure>
<h3 id="usb接口"><a href="#usb接口" class="headerlink" title="usb接口"></a>usb接口</h3><p>usb接口通过usb_interface结构来表示，表示一个usb设备的某个接口。</p>
<p>通过下面的接口判断设备是否为usb接口设备：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline int is_usb_interface(const struct device *dev)</span><br></pre></td></tr></table></figure>
<h2 id="USB驱动类型"><a href="#USB驱动类型" class="headerlink" title="USB驱动类型"></a>USB驱动类型</h2><h3 id="驱动结构"><a href="#驱动结构" class="headerlink" title="驱动结构"></a>驱动结构</h3><p>和usb设备对应，在linux内核usb设备驱动模型中，usb驱动分为设备驱动和接口驱动，usb设备驱动用来解析和配置usb接口设备，以及注册usb的接口设备。</p>
<p>usb的设备驱动在内核中用usb_device_driver结构表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct usb_device_driver &#123;</span><br><span class="line">        const char *name;</span><br><span class="line">                </span><br><span class="line">        int (*probe) (struct usb_device *udev);</span><br><span class="line">        void (*disconnect) (struct usb_device *udev);</span><br><span class="line">                </span><br><span class="line">        int (*suspend) (struct usb_device *udev, pm_message_t message);</span><br><span class="line">        int (*resume) (struct usb_device *udev, pm_message_t message);</span><br><span class="line">        struct usbdrv_wrap drvwrap;</span><br><span class="line">        unsigned int supports_autosuspend:1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>usb的接口驱动在内核中用usb_driver结构表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct usb_driver &#123;</span><br><span class="line">        const char *name;</span><br><span class="line"></span><br><span class="line">        int (*probe) (struct usb_interface *intf,</span><br><span class="line">                      const struct usb_device_id *id);</span><br><span class="line"></span><br><span class="line">        void (*disconnect) (struct usb_interface *intf);</span><br><span class="line"></span><br><span class="line">        int (*unlocked_ioctl) (struct usb_interface *intf, unsigned int code,</span><br><span class="line">                        void *buf);</span><br><span class="line"></span><br><span class="line">        int (*suspend) (struct usb_interface *intf, pm_message_t message);</span><br><span class="line">        int (*resume) (struct usb_interface *intf);</span><br><span class="line">        int (*reset_resume)(struct usb_interface *intf);</span><br><span class="line"></span><br><span class="line">        int (*pre_reset)(struct usb_interface *intf);</span><br><span class="line">        int (*post_reset)(struct usb_interface *intf);</span><br><span class="line"></span><br><span class="line">        const struct usb_device_id *id_table;</span><br><span class="line"></span><br><span class="line">        struct usb_dynids dynids;</span><br><span class="line">        struct usbdrv_wrap drvwrap;</span><br><span class="line">        unsigned int no_dynamic_id:1;</span><br><span class="line">        unsigned int supports_autosuspend:1;</span><br><span class="line">        unsigned int disable_hub_initiated_lpm:1;</span><br><span class="line">        unsigned int soft_unbind:1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="驱动类型的区分"><a href="#驱动类型的区分" class="headerlink" title="驱动类型的区分"></a>驱动类型的区分</h3><p>在usb_device_driver和usb_driver结构中都包含一个usbdrv_wrap类型的drvwrap成员，该成员结构定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct usbdrv_wrap &#123;</span><br><span class="line">        struct device_driver driver;</span><br><span class="line">        int for_devices;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中driver成员是usb驱动结构中内嵌的device_driver对象，是设备驱动模型的driver部件。for_device成员用来表示该驱动是usb设备驱动还是usb接口驱动。for_device的值为1表示usb设备驱动，为0表示usb接口驱动。</p>
<p>内核中通过下面的接口判断usb驱动是设备驱动还是接口驱动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline int is_usb_device_driver(struct device_driver *drv)</span><br></pre></td></tr></table></figure>
<h3 id="驱动注册"><a href="#驱动注册" class="headerlink" title="驱动注册"></a>驱动注册</h3><p>usb设备驱动的注册和注销接口如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int usb_register_device_driver(struct usb_device_driver *new_udriver,</span><br><span class="line">                struct module *owner)；</span><br><span class="line">void usb_deregister_device_driver(struct usb_device_driver *udriver)；</span><br></pre></td></tr></table></figure>
<p>设备驱动注册函数中对drvwrap.for_devices成员赋值为1，表示注册的usb驱动是usb设备驱动，并且调用driver_register接口将drvwrap.driver注册到内核设备驱动模型中。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new_udriver-&gt;drvwrap.for_devices = 1;</span><br><span class="line">new_udriver-&gt;drvwrap.driver.name = new_udriver-&gt;name;</span><br><span class="line">new_udriver-&gt;drvwrap.driver.bus = &amp;usb_bus_type;</span><br><span class="line">new_udriver-&gt;drvwrap.driver.probe = usb_probe_device;</span><br><span class="line">new_udriver-&gt;drvwrap.driver.remove = usb_unbind_device;</span><br><span class="line">new_udriver-&gt;drvwrap.driver.owner = owner;</span><br><span class="line"></span><br><span class="line">retval = driver_register(&amp;new_udriver-&gt;drvwrap.driver);</span><br></pre></td></tr></table></figure>
<p>usb接口驱动的注册和注销接口如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* use a define to avoid include chaining to get THIS_MODULE &amp; friends */</span><br><span class="line">#define usb_register(driver) \</span><br><span class="line">        usb_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)</span><br><span class="line">extern void usb_deregister(struct usb_driver *);</span><br></pre></td></tr></table></figure>
<p>接口驱动注册函数中对drvwrap.for_devices成员赋值为0，表示注册的是一个usb接口驱动，并且调用driver_register接口将drvwrap.driver注册到内核设备驱动模型中。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new_driver-&gt;drvwrap.for_devices = 0;</span><br><span class="line">new_driver-&gt;drvwrap.driver.name = new_driver-&gt;name;</span><br><span class="line">new_driver-&gt;drvwrap.driver.bus = &amp;usb_bus_type;</span><br><span class="line">new_driver-&gt;drvwrap.driver.probe = usb_probe_interface;</span><br><span class="line">new_driver-&gt;drvwrap.driver.remove = usb_unbind_interface;</span><br><span class="line">new_driver-&gt;drvwrap.driver.owner = owner;</span><br><span class="line">new_driver-&gt;drvwrap.driver.mod_name = mod_name;</span><br><span class="line">spin_lock_init(&amp;new_driver-&gt;dynids.lock);</span><br><span class="line">INIT_LIST_HEAD(&amp;new_driver-&gt;dynids.list);</span><br><span class="line"></span><br><span class="line">retval = driver_register(&amp;new_driver-&gt;drvwrap.driver);</span><br></pre></td></tr></table></figure>
<h2 id="USB设备驱动模型"><a href="#USB设备驱动模型" class="headerlink" title="USB设备驱动模型"></a>USB设备驱动模型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>usb设备驱动模型是内核设备驱动模型的应用，它包含usb总线，usb设备和usb驱动，以及用户空间视图的sysfs等。</p>
<p>usb总线的作用是维护所有的usb设备和usb驱动，以及为usb设备和usb驱动创建关联，以达到用户通过usb驱动操作关联的usb设备的目的。</p>
<h3 id="USB总线"><a href="#USB总线" class="headerlink" title="USB总线"></a>USB总线</h3><p>usb总线在内核中的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct bus_type usb_bus_type = &#123;</span><br><span class="line">        .name =         &quot;usb&quot;,</span><br><span class="line">        .match =        usb_device_match,</span><br><span class="line">        .uevent =       usb_uevent,</span><br><span class="line">        .need_parent_lock =     true,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总线名称为usb，即在/sys/bus/目录下存在usb目录，表示usb总线。</p>
<p>match函数指针用来进行设备和驱动的匹配，当向总线上添加一个usb设备(或usb驱动)时，linux内核设备驱动模型核心就会遍历usb总线上的驱动(或设备)，并为其调用usb总线的match方法，以判断新插入的设备能否被某个驱动处理。match方法成功返回1，否则返回0。当内核设备驱动核心得到匹配成功的结果后就会为usb设备和usb驱动创建关联，并调用驱动的probe函数。</p>
<p>在usb总线的match方法中需要判断驱动和设备的类型，设备和驱动都分为usb设备和接口两个类型。对于设备类型和设备驱动类型的匹配，直接返回成功，而对于接口设备和接口驱动的匹配，则需要通过接口驱动的id_table成员中的信息和接口设备的信息进行匹配。id_table由usb接口驱动设置，用来描述该驱动能处理那些设备。</p>
<h3 id="usb设备-1"><a href="#usb设备-1" class="headerlink" title="usb设备"></a>usb设备</h3><p>usb设备分为usb设备和usb接口设备两种，通常一个usb物理设备关联一个usb设备对象，usb设备对象关联一个或多个usb接口对象。</p>
<p>当一个新的usb设备对象或者usb设备接口对象被注册到usb总线上的时候，内核设备驱动核心为其在usb总线上查找能处理其的驱动，并执行驱动的probe函数，以初始化设备和提供相关操作函数。</p>
<h3 id="usb驱动"><a href="#usb驱动" class="headerlink" title="usb驱动"></a>usb驱动</h3><p>usb驱动也分为usb设备驱动和usb接口设备，usb设备驱动用来处理usb设备，usb接口驱动用来处理usb接口。通常大部分usb驱动都是usb接口驱动，比如usb存储，usb串口等。</p>
<p>在usb子系统初始化的时候会注册一个与设备相关的usb通用设备驱动，由usb总线match函数的代码可知该驱动能匹配所有usb设备。</p>
<p>当usb hub的事件线程监测到设备接入后，会向usb总线上注册新接入的设备，注册的设备首先将和usb通用驱动进行绑定，在usb通用驱动的probe函数中再申请注册usb接口设备。当usb接口设备注册到usb总线上时，再进行接口设备和接口驱动的绑定。</p>
<h3 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h3><p>sysfs是内核设备驱动模型的用户空间视图，usb子系统在sysfs中的路径是/sys/bus/usb目录。该目录下存在devices和drivers目录，用来呈现usb总线上的设备和驱动。</p>
<h3 id="generic驱动"><a href="#generic驱动" class="headerlink" title="generic驱动"></a>generic驱动</h3><p>generic驱动在usb子系统初始化的时候由usb核心注册。该驱动负责处理所有的usb物理设备，当usb hub驱动监测到设备接入后，会向usb总线上注册新接入的设备，注册的设备首先将会和usb通用设备驱动关联，并调用usb_generic_driver的probe函数。</p>
<p>在usb_generic_driver的probe函数中，将对设备进行配置和解析，并向usb总线注册该usb设备的设备接口设备。</p>
<p>当接口设备注册到usb总线上时，设备驱动核心将会为其在usb总线上查找和关联驱动，并调用关联驱动的probe函数。</p>
<p>比如插入一个4G模块，将由usb_generic_driver配置4G模块的所有接口，并将接口注册到usb总线上，然后由设备驱动模型核心再为4G模块的所有接口在usb总线上查找和关联4G相关的驱动。</p>
<h3 id="hub驱动"><a href="#hub驱动" class="headerlink" title="hub驱动"></a>hub驱动</h3><p>usb的hub驱动也是一个usb总线上的接口驱动，root hub设备由usb的host控制器驱动来创建和注册，当host驱动向usb总线注册了root hub设备的时候就会匹配到usb的hub驱动。</p>
<p>hub驱动会不停的监测新设备的接入。当hub驱动监测到新usb设备接入时会向内核设备驱动模型核心申请和注册usb设备，新设备所属总线为usb总线，所以当设备注册到usb总线上时，内核设备驱动模型核心会在usb总线上为其查找和绑定合适的usb驱动。</p>
<h2 id="USB控制器驱动"><a href="#USB控制器驱动" class="headerlink" title="USB控制器驱动"></a>USB控制器驱动</h2><p>usb的主控制器驱动结构为hc_driver，对应的usb主控制器设备的结构为usb_hcd，hc_driver用来处理相应的usb_hcd。usb的控制器属于上一级的总线设备驱动模型的子节点，比如硬件上挂在pci总线上的usb控制器本身由pci核心来枚举，pci总线上的所有设备抽象为pci_dev结构，驱动抽象为pci_driver结构。当pci总线上枚举到pci_dev设备并注册设备后，将会调用pci_driver的probe函数并绑定pci_driver，在pci_driver的probe函数中，将创建和添加usb_hcd，同时从pci的pci_device_id中获取到hc_driver，并将hc_driver和usb_hcd绑定。</p>
<h3 id="usb主控制器（hcd）"><a href="#usb主控制器（hcd）" class="headerlink" title="usb主控制器（hcd）"></a>usb主控制器（hcd）</h3><p>linux内核中用usb_hcd类型来描述一个usb主控制器，一个usb主控制器通常对应一个usb_bus类型的总线（此总线非设备驱动模型之总线）来维护该控制器上的设备树。</p>
<p>一个usb主控制器通常对应一个root hub设备，root hub设备是usb_device结构类型的。root hub作为usb总线（usb_bus）设备树上的其它usb设备的父设备，它被关联在usb_bus结构中。</p>
<p>root  hub作为usb_device类型的对象，其关联的设备驱动模型的总线是usb总线，关联的设备驱动是usb hub驱动。在添加usb_hcd的时候，将会注册usb_bus以及root hub。root hub被初始化和注册后和usb hub驱动创建关联，之后的事就交给hub驱动和hub线程了。</p>
<h3 id="控制器驱动（hc）"><a href="#控制器驱动（hc）" class="headerlink" title="控制器驱动（hc）"></a>控制器驱动（hc）</h3><p>控制器驱动主要提供控制器的硬件操作。比如中断设置，提供控制器的初始化，开始停止，urb入队出队，usb端点屏蔽使能，hub状态获取，数据通信控制等功能。</p>
<h2 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h2><h3 id="USB子系统初始化"><a href="#USB子系统初始化" class="headerlink" title="USB子系统初始化"></a>USB子系统初始化</h3><p>1.初始化debugfs，注册usb acpi总线。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usb_init_pool_max();</span><br><span class="line"></span><br><span class="line">usb_debugfs_init();</span><br></pre></td></tr></table></figure>
<p>2.注册usb总线。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">retval = bus_register(&amp;usb_bus_type);</span><br><span class="line">if (retval)</span><br><span class="line">    goto bus_register_failed;</span><br></pre></td></tr></table></figure>
<p>usb_bus_type定义和初始化代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct bus_type usb_bus_type = &#123;</span><br><span class="line">        .name =         &quot;usb&quot;,</span><br><span class="line">        .match =        usb_device_match,</span><br><span class="line">        .uevent =       usb_uevent,</span><br><span class="line">        .need_parent_lock =     true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由usb总线的定义可知，总线名称为“usb”，匹配方法为usb_device_match函数，uevent方法为usb_uevent。</p>
<p>3.注册usb总线通知链。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">retval = bus_register_notifier(&amp;usb_bus_type, &amp;usb_bus_nb);</span><br><span class="line">if (retval)</span><br><span class="line">    goto bus_notifier_failed;</span><br></pre></td></tr></table></figure>
<p>通知链是linux内核用来实现异步通知的一种机制，通知链由一个通知链头结构和一些通知链上的block组成。usb核心会把一些事件发送到通知链，通知链核心将遍历通知链上的所有block，并调用block的回调函数以实现异步的效果。</p>
<p>总线上的通知链头结构包含在总线结构的p成员结构中。</p>
<p>usb总线通知链初始化的时候注册了一个通知块usb_bus_nb，该通知块定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static struct notifier_block usb_bus_nb = &#123;</span><br><span class="line">        .notifier_call = usb_bus_notify,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通知块回调函数为usb_bus_notify，该函数接收处理总线上添加或删除设备/接口设备的事件，当usb核心向内核设备驱动模型中添加或删除usb设备或接口设备后，向usb总线上发送通知，在usb_bus_notify通知处理函数中，向sysfs添加或删除设备或接口设备的属性文件。</p>
<p>4.注册usb主设备号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">retval = usb_major_init();</span><br><span class="line">if (retval)</span><br><span class="line">    goto major_init_failed;</span><br></pre></td></tr></table></figure>
<p>在usb_major_init函数中调用register_chrdev接口向内核注册了usb主设备号，usb的主设备号用USB_MAJOR宏定义，该宏定义的值为180。</p>
<p>5.注册usbfs接口驱动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">retval = usb_register(&amp;usbfs_driver);</span><br><span class="line">if (retval)</span><br><span class="line">	goto driver_register_failed;</span><br></pre></td></tr></table></figure>
<p>6.初始化usb字符设备io空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">retval = usb_devio_init();</span><br><span class="line">if (retval)</span><br><span class="line">    goto usb_devio_init_failed;</span><br></pre></td></tr></table></figure>
<p>6.1在usb_devio_init函数中，首先按最大值为usb设备申请字符设备：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">retval = register_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX,</span><br><span class="line">					&quot;usb_device&quot;);</span><br><span class="line">if (retval) &#123;</span><br><span class="line">	printk(KERN_ERR &quot;Unable to register minors for usb_device\n&quot;);</span><br><span class="line">	goto out;</span><br><span class="line">&#125;</span><br><span class="line">cdev_init(&amp;usb_device_cdev, &amp;usbdev_file_operations);</span><br><span class="line">retval = cdev_add(&amp;usb_device_cdev, USB_DEVICE_DEV, USB_DEVICE_MAX);</span><br><span class="line">if (retval) &#123;</span><br><span class="line">	printk(KERN_ERR &quot;Unable to get usb_device major %d\n&quot;,</span><br><span class="line">		   USB_DEVICE_MAJOR);</span><br><span class="line">	goto error_cdev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.2接着向usb内部通知链usb_notifier_list上注册通知块usbdev_nb：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usb_register_notify(&amp;usbdev_nb);</span><br></pre></td></tr></table></figure>
<p>usbdev_nb定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static struct notifier_block usbdev_nb = &#123;</span><br><span class="line">	.notifier_call =	usbdev_notify,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在usbdev_notify回调函数中判读如果有usb设备移除了，就会做一些相应的文件io回收释放等操作。</p>
<p>7.注册usb hub驱动，申请hub工作队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">retval = usb_hub_init();</span><br><span class="line">if (retval)</span><br><span class="line">	goto hub_init_failed;</span><br></pre></td></tr></table></figure>
<p>7.1在usb_hub_init函数中，首先注册了hub_driver。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (usb_register(&amp;hub_driver) &lt; 0) &#123;</span><br><span class="line">            printk(KERN_ERR &quot;%s: can&apos;t register hub driver\n&quot;,</span><br><span class="line">                    usbcore_name);</span><br><span class="line">     return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hub_driver定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static struct usb_driver hub_driver = &#123;</span><br><span class="line">    .name =         &quot;hub&quot;,</span><br><span class="line">    .probe =        hub_probe,</span><br><span class="line">    .disconnect =   hub_disconnect,</span><br><span class="line">    .suspend =      hub_suspend,</span><br><span class="line">    .resume =       hub_resume,</span><br><span class="line">    .reset_resume = hub_reset_resume,</span><br><span class="line">    .pre_reset =    hub_pre_reset,</span><br><span class="line">    .post_reset =   hub_post_reset,</span><br><span class="line">    .unlocked_ioctl = hub_ioctl,</span><br><span class="line">    .id_table =     hub_id_table,</span><br><span class="line">    .supports_autosuspend = 1,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由该定义可知，usb hub驱动是一个接口设备驱动，驱动名称为“hub”，id_table成员为hub_id_table，probe函数为hub_probe，当一个hub设备添加到内核设备驱动模型中的时候，如果hub设备测参数和hub_id_table中的参数匹配，就会调用到hub_probe函数。</p>
<p>7.2注册了hub_driver之后，申请hub工作队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hub_wq = alloc_workqueue(&quot;usb_hub_wq&quot;, WQ_FREEZABLE, 0);</span><br><span class="line">if (hub_wq)</span><br><span class="line">    return 0;</span><br></pre></td></tr></table></figure>
<p>在hub的中断轮询的时候，在回调函数hub_irq中就会向hub_wq中添加任务。在该任务中再去做hub端口检查，新设备枚举等工作。</p>
<p>8.注册usb通用驱动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">retval = usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE);</span><br><span class="line">if (!retval)</span><br><span class="line">	goto out;</span><br></pre></td></tr></table></figure>
<p>至此，完成usb子系统的初始化。</p>
<h3 id="USB总线匹配方法"><a href="#USB总线匹配方法" class="headerlink" title="USB总线匹配方法"></a>USB总线匹配方法</h3><p>usb子系统初始化的时候向内核设备驱动模型注册了usb_bus_type总线类型，该总线初始化match方法为usb_device_match函数。usb的匹配条件由usb_device_id结构描述，只有usb_driver驱动结构具有该类型的成员id_table，usb_device_driver结构没有此成员。usb_device_id在内核中的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct usb_device_id &#123;</span><br><span class="line">    /* which fields to match against? */</span><br><span class="line">    __u16           match_flags;</span><br><span class="line"></span><br><span class="line">    /* Used for product specific matches; range is inclusive */</span><br><span class="line">    __u16           idVendor;</span><br><span class="line">    __u16           idProduct;</span><br><span class="line">    __u16           bcdDevice_lo;</span><br><span class="line">    __u16           bcdDevice_hi;</span><br><span class="line">      </span><br><span class="line">    /* Used for device class matches */     </span><br><span class="line">    __u8            bDeviceClass;</span><br><span class="line">    __u8            bDeviceSubClass;</span><br><span class="line">    __u8            bDeviceProtocol;</span><br><span class="line"></span><br><span class="line">    /* Used for interface class matches */</span><br><span class="line">    __u8            bInterfaceClass;</span><br><span class="line">    __u8            bInterfaceSubClass;</span><br><span class="line">    __u8            bInterfaceProtocol;</span><br><span class="line"></span><br><span class="line">    /* Used for vendor-specific interface matches */</span><br><span class="line">    __u8            bInterfaceNumber;</span><br><span class="line"></span><br><span class="line">    /* not matched against */</span><br><span class="line">    kernel_ulong_t  driver_info</span><br><span class="line">            __attribute__((aligned(sizeof(kernel_ulong_t))));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>usb总线match方法通过usb接口驱动的该结构成员与接口设备的属性进行匹配来判断驱动和设备是否可以关联。</p>
<p>1.判断设备类型和驱动类型，如果设备类型是usb设备，驱动类型是usb设备驱动，则直接返回成功，即所有的usb设备都会和usb genery driver匹配成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (is_usb_device(dev)) &#123;</span><br><span class="line"></span><br><span class="line">    /* interface drivers never match devices */</span><br><span class="line">    if (!is_usb_device_driver(drv))</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">        /* TODO: Add real matching code */</span><br><span class="line">        return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.如果是usb接口设备，并且是接口驱动，则需要调用usb_match_id函数，通过usb驱动的id_table成员去匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id = usb_match_id(intf, usb_drv-&gt;id_table);</span><br><span class="line">if (id)</span><br><span class="line">    return 1;</span><br></pre></td></tr></table></figure>
<p>2.1.在usb_match_id函数中调用usb_match_one_id函数进行id匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (; id-&gt;idVendor || id-&gt;idProduct || id-&gt;bDeviceClass ||</span><br><span class="line">    	id-&gt;bInterfaceClass || id-&gt;driver_info; id++) &#123;</span><br><span class="line">    if (usb_match_one_id(interface, id))</span><br><span class="line">        return id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.1.1在usb_match_one_id函数中首先判断设备条件是否匹配，然后继续判断接口条件是否匹配。这两个条件满足则匹配成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!usb_match_device(dev, id))</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">return usb_match_one_id_intf(dev, intf, id);</span><br></pre></td></tr></table></figure>
<p>3.如果usb_match_id匹配不成功，则继续调用usb_match_dynamic_id和动态ID进行匹配。在这里动态id实际匹配过程和上面静态id的实际匹配过程相同，不同之处在于，静态id由驱动的id_table成员提供并随内核或模块编译而静态生成，而动态id则是由用户空间通过sysfs中驱动的new_id属性文件操作而生成，动态id是由usb_driver结构的dynids成员维护的一个链表。dynamic_id功能需要内核配置开启。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id = usb_match_dynamic_id(intf, usb_drv);</span><br><span class="line">if (id)</span><br><span class="line">    return 1;</span><br></pre></td></tr></table></figure>
<h3 id="USB-通用驱动"><a href="#USB-通用驱动" class="headerlink" title="USB 通用驱动"></a>USB 通用驱动</h3><p>当usb的hub任务监测到新设备接入时就会枚举新USB设备，新USB设备将会被添加到内核设备驱动模型中，根据usb的匹配函数可知，对于usb_device_type类型的设备，直接和usb设备驱动匹配成功，这里匹配到的设备驱动就是在usb子系统初始化的时候创建的usb_generic_driver驱动，所有的usb设备接入后先和该驱动绑定，然后再由该驱动枚举设备的接口设备。该驱动类型是usb_device_driver，一般其他的usb驱动都是usb_driver类型的，即usb接口设备驱动。usb_generic_driver在内核中定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct usb_device_driver usb_generic_driver = &#123;</span><br><span class="line">    .name = &quot;usb&quot;,</span><br><span class="line">    .probe = generic_probe,</span><br><span class="line">    .disconnect = generic_disconnect,</span><br><span class="line">#ifdef  CONFIG_PM        .suspend = generic_suspend,</span><br><span class="line">    .resume = generic_resume,</span><br><span class="line">#endif  </span><br><span class="line">    .supports_autosuspend = 1,&#125;;</span><br></pre></td></tr></table></figure>
<p>由该定义可知，usb_generic_driver驱动的名称为“usb”，probe函数为generic_probe。下面分析probe流程。</p>
<p>1.在generic_probe函数中首先调用usb_choose_configuration函数根据设备的配置信息，选择一个最佳的配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = usb_choose_configuration(udev);</span><br></pre></td></tr></table></figure>
<p>2.调用usb_set_configuration接口枚举和申请注册usb接口设备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = usb_set_configuration(udev, c);</span><br></pre></td></tr></table></figure>
<p>当接口添加到设备驱动模型中后，设备驱动模型核心再去为接口设备在usb总线上匹配和绑定接口驱动。</p>
<h3 id="USB-HUB驱动"><a href="#USB-HUB驱动" class="headerlink" title="USB HUB驱动"></a>USB HUB驱动</h3><p>usb的hub驱动在内核中的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static struct usb_driver hub_driver = &#123;</span><br><span class="line">    .name =         &quot;hub&quot;,</span><br><span class="line">    .probe =        hub_probe,</span><br><span class="line">    .disconnect =   hub_disconnect,</span><br><span class="line">    .suspend =      hub_suspend,</span><br><span class="line">    .resume =       hub_resume,</span><br><span class="line">    .reset_resume = hub_reset_resume,</span><br><span class="line">    .pre_reset =    hub_pre_reset,</span><br><span class="line">    .post_reset =   hub_post_reset,</span><br><span class="line">    .unlocked_ioctl = hub_ioctl,</span><br><span class="line">    .id_table =     hub_id_table,</span><br><span class="line">    .supports_autosuspend = 1,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由定义可知，hub驱动的probe函数是hub_probe，下面是hub_probe函数的代码核心部分的流程：</p>
<p>1.首先申请和初始化hub。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hub = kzalloc(sizeof(*hub), GFP_KERNEL);</span><br><span class="line">if (!hub)</span><br><span class="line">    return -ENOMEM;</span><br><span class="line"></span><br><span class="line">kref_init(&amp;hub-&gt;kref);</span><br><span class="line">hub-&gt;intfdev = &amp;intf-&gt;dev;</span><br><span class="line">hub-&gt;hdev = hdev;</span><br><span class="line">INIT_DELAYED_WORK(&amp;hub-&gt;leds, led_work);</span><br><span class="line">INIT_DELAYED_WORK(&amp;hub-&gt;init_work, NULL);</span><br><span class="line">INIT_WORK(&amp;hub-&gt;events, hub_event);</span><br><span class="line">spin_lock_init(&amp;hub-&gt;irq_urb_lock);</span><br><span class="line">timer_setup(&amp;hub-&gt;irq_urb_retry, hub_retry_irq_urb, 0);</span><br></pre></td></tr></table></figure>
<p>其中，初始化了hub的events成员，该成员是work_struct类型的，属于工作队列的上的一个实例，其回调函数设置为hub_event函数。</p>
<p>2.调用hub_config为hub申请资源，进一步初始化，以及开启hub中断轮询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (hub_configure(hub, &amp;desc-&gt;endpoint[0].desc) &gt;= 0)</span><br><span class="line">    return 0;</span><br></pre></td></tr></table></figure>
<p>2.1在hub_configure中首先申请各种hub的资源，获取hub描述符，初始化资源等。其中也申请和初始化usb数据传输相关的资源，有管道，端点，urb等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pipe = usb_rcvintpipe(hdev, endpoint-&gt;bEndpointAddress);</span><br><span class="line">maxp = usb_maxpacket(hdev, pipe, usb_pipeout(pipe));</span><br><span class="line">maxp = usb_maxpacket(hdev, pipe, usb_pipeout(pipe));</span><br><span class="line">    maxp = sizeof(*hub-&gt;buffer);</span><br><span class="line"></span><br><span class="line">hub-&gt;urb = usb_alloc_urb(0, GFP_KERNEL);</span><br><span class="line">if (!hub-&gt;urb) &#123;</span><br><span class="line">    ret = -ENOMEM;</span><br><span class="line">    goto fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usb_fill_int_urb(hub-&gt;urb, hdev, pipe, *hub-&gt;buffer, maxp, hub_irq,</span><br><span class="line">        hub, endpoint-&gt;bInterval);</span><br></pre></td></tr></table></figure>
<p>可以看到在设置urb的时候设置的中断轮询的回调函数是hub_irq。</p>
<p>2.2调用hub_activate函数开始hub的中断轮询和事件处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hub_activate(hub, HUB_INIT);</span><br></pre></td></tr></table></figure>
<p>在hub_activate函数中继续做一些hub端口以及其他资源的初始化，最后会向usb核心提交上一步设置的urb。当urb轮询得到设备的回复后就会调用到设置urb的时候设置的中断轮询的回调函数hub_irq。</p>
<p>3.hub_irq函数</p>
<p>hub_irq函数是hub中断轮询的回调函数，该函数首先调用kick_hub_wq函数，以唤醒hub工作队列处理轮询结果，然后调用hub_resubmit_irq_urb函数重新提交中断轮询urb以继续监测hub端口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Something happened, let hub_wq figure it out */</span><br><span class="line">kick_hub_wq(hub);</span><br><span class="line"></span><br><span class="line">resubmit:</span><br><span class="line">    hub_resubmit_irq_urb(hub);</span><br></pre></td></tr></table></figure>
<p>kick_hub_wq中会调用queue_work调度hub的events工作，前面的流程中events的回调函数设置为hub_event函数，所以工作队列调度events就会执行到hub_event回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (queue_work(hub_wq, &amp;hub-&gt;events))</span><br><span class="line">    return;</span><br></pre></td></tr></table></figure>
<p>4.hub_event函数中检查如果有事件产生则对所有端口调用port_event函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/* deal with port status changes */</span><br><span class="line">for (i = 1; i &lt;= hdev-&gt;maxchild; i++) &#123;</span><br><span class="line">	struct usb_port *port_dev = hub-&gt;ports[i - 1];</span><br><span class="line"></span><br><span class="line">	if (test_bit(i, hub-&gt;event_bits)</span><br><span class="line">			|| test_bit(i, hub-&gt;change_bits)</span><br><span class="line">			|| test_bit(i, hub-&gt;wakeup_bits)) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * The get_noresume and barrier ensure that if</span><br><span class="line">		 * the port was in the process of resuming, we</span><br><span class="line">		 * flush that work and keep the port active for</span><br><span class="line">		 * the duration of the port_event().  However,</span><br><span class="line">		 * if the port is runtime pm suspended</span><br><span class="line">		 * (powered-off), we leave it in that state, run</span><br><span class="line">		 * an abbreviated port_event(), and move on.</span><br><span class="line">		 */</span><br><span class="line">		pm_runtime_get_noresume(&amp;port_dev-&gt;dev);</span><br><span class="line">		pm_runtime_barrier(&amp;port_dev-&gt;dev);</span><br><span class="line">		usb_lock_port(port_dev);</span><br><span class="line">		port_event(hub, i);</span><br><span class="line">		usb_unlock_port(port_dev);</span><br><span class="line">		pm_runtime_put_sync(&amp;port_dev-&gt;dev);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.1在port_event中检查如果是否有connect_change产生，有则调用hub_port_connect_change函数进行处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (connect_change)</span><br><span class="line">	hub_port_connect_change(hub, port1, portstatus, portchange);</span><br></pre></td></tr></table></figure>
<p>4.1.1在hub_port_connect_change函数中调用hub_port_connect函数，处理端口上的连接事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hub_port_connect(hub, port1, portstatus, portchange);</span><br></pre></td></tr></table></figure>
<p>4.1.1.1在hub_port_connect函数中，调用usb_alloc_dev接口申请usb设备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">udev = usb_alloc_dev(hdev, hdev-&gt;bus, port1);</span><br><span class="line">if (!udev) &#123;</span><br><span class="line">	dev_err(&amp;port_dev-&gt;dev,</span><br><span class="line">			&quot;couldn&apos;t allocate usb_device\n&quot;);</span><br><span class="line">	goto done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.1.1.2为新接入的设备选择一个地址编号以提供枚举时使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">choose_devnum(udev);</span><br><span class="line">if (udev-&gt;devnum &lt;= 0) &#123;</span><br><span class="line">	status = -ENOTCONN;	/* Don&apos;t retry */</span><br><span class="line">	goto loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择的设备编号最终将在hub_port_init函数中通过hub_set_address接口设置给usb设备。</p>
<p>4.1.1.3调用hub_port_init函数复位设备和获取设备描述符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status = hub_port_init(hub, udev, port1, i);</span><br></pre></td></tr></table></figure>
<p>在usb设备枚举之前，使用端点0进行通信。</p>
<p>4.1.1.4调用usb_new_device接口枚举和注册usb设备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status = usb_new_device(udev);</span><br></pre></td></tr></table></figure>
<p>在该接口中会获取设备的配置描述符，并注册usb设备到内核设备驱动模型中，它将会和usb generic驱动绑定并由generic驱动去解析和注册其接口设备。</p>
<h3 id="USB-HCD注册"><a href="#USB-HCD注册" class="headerlink" title="USB_HCD注册"></a>USB_HCD注册</h3><p>以ehci_hcd_pci为例说明，下面的源代码分析省略了硬件上的初始化部分，比如唤醒使能，one-time初始化等等。</p>
<p>1.执行ehci_pci_probe</p>
<p>当pci_driver的probe被执行的时候，会调用到usb核心层的usb_hcd_pci_probe函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int ehci_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)</span><br><span class="line">&#123;   </span><br><span class="line">        if (is_bypassed_id(pdev))</span><br><span class="line">                return -ENODEV;</span><br><span class="line">        return usb_hcd_pci_probe(pdev, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.创建usb_hcd</p>
<p>在ehci_pci_probe中首先会创建usb_hcd。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hcd = usb_create_hcd(driver, &amp;dev-&gt;dev, pci_name(dev));</span><br><span class="line">if (!hcd) &#123;</span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">    goto disable_pci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.添加usb_hcd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">retval = usb_add_hcd(hcd, hcd_irq, IRQF_SHARED);</span><br><span class="line">if (retval != 0)</span><br><span class="line">    dev_set_drvdata(&amp;dev-&gt;dev, NULL);</span><br></pre></td></tr></table></figure>
<p>3.1.注册usb_bus</p>
<p>在usb_add_hcd函数中调用usb_register_bus注册usb_bus，该注册函数实现上就是在usb_bus_idr空间中为要注册的usb_bus申请一席之地，即usb_bus结构中的busnum成员，然后向usb通知中心发送添加usb_bus的事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">retval = usb_register_bus(&amp;hcd-&gt;self);</span><br><span class="line">if (retval &lt; 0)</span><br><span class="line">    goto err_register_bus;</span><br></pre></td></tr></table></figure>
<p>3.2.为usb_bus申请root hub设备</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rhdev = usb_alloc_dev(NULL, &amp;hcd-&gt;self, 0);</span><br><span class="line">if (rhdev == NULL) &#123;</span><br><span class="line">    dev_err(hcd-&gt;self.sysdev, &quot;unable to allocate root hub\n&quot;);</span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">    goto err_allocate_root_hub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里usb_alloc_dev是一个创建新usb设备的接口，该接口中申请usb_device设备，并且指定usb_device设备所属的设备驱动模型总线是usb_bus_type，设备类型是usb_device_type。同时初始化usb_device的其它成员。</p>
<p>3.3.调用register_root_hub注册root hub</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* starting here, usbcore will pay attention to this root hub */</span><br><span class="line">retval = register_root_hub(hcd);</span><br><span class="line">if (retval != 0)</span><br><span class="line">    goto err_register_root_hub;</span><br></pre></td></tr></table></figure>
<p>3.3.1在register_root_hub函数中调用usb_new_device将root hub设备注册到内核设备驱动模型中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">retval = usb_new_device (usb_dev);</span><br><span class="line">if (retval) &#123;</span><br><span class="line">    dev_err (parent_dev, &quot;can&apos;t register root hub for %s, %d\n&quot;,</span><br><span class="line">                    dev_name(&amp;usb_dev-&gt;dev), retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的usb_new_device是一个枚举和注册usb设备的接口，该接口中调用usb_enumerate_device函数读取设备的描述符以枚举设备，之后会调用device_add接口将新的usb设备注册到设备驱动模型中。</p>
<p>至此，完成usb hcd的注册。</p>
<h2 id="usb驱动编写流程"><a href="#usb驱动编写流程" class="headerlink" title="usb驱动编写流程"></a>usb驱动编写流程</h2><p>一般usb驱动指的是usb接口设备驱动。</p>
<h3 id="定义驱动"><a href="#定义驱动" class="headerlink" title="定义驱动"></a>定义驱动</h3><p>1.定义驱动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct usb_driver xxx = &#123;</span><br><span class="line">	.name = &quot;xxx&quot;,</span><br><span class="line">	.probe = xxx_probe,</span><br><span class="line">	.disconnect = xxx_disconnect,</span><br><span class="line">	.id_table = xxx_id_table,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.定义id_table，描述该驱动能处理哪些设备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static struct usb_device_id xxx_id_table = &#123;</span><br><span class="line">    &#123;USB_DEVICE(0x1234, 0x5678)&#125;,</span><br><span class="line">    &#123;&#125; /* Terminating entry */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在id_table中可以描述多个匹配信息，上例是匹配厂家ID为0x1234, 产品ID为0x5678的所有设备。可以写入接口信息，或者接口设备组合信息。</p>
<p>3.实现probe和disconnect函数，probe函数用来在设备添加到内核中后对设备进行初始化，资源维护以及提供相关功能。disconnect函数用来在设备拨出后释放资源等操作。</p>
<h3 id="注册驱动"><a href="#注册驱动" class="headerlink" title="注册驱动"></a>注册驱动</h3><p>使用module_usb_driver接口将usb驱动注册到usb核心，module_usb_driver是一个宏，展开后使用提供模块init和exit函数，以及使用usb_register接口注册usb驱动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module_usb_driver(xxx);</span><br></pre></td></tr></table></figure>
<h3 id="驱动功能"><a href="#驱动功能" class="headerlink" title="驱动功能"></a>驱动功能</h3><p>驱动功能在驱动probe函数中实现。probe函数原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int (*probe) (struct usb_interface *intf,</span><br><span class="line">		  const struct usb_device_id *id);</span><br></pre></td></tr></table></figure>
<p>在probe函数中根据接口信息获取接口的传输端点，一般鼠标和hub设备等实时性要求高，传输数据少的接口使用中断传输端点，而要求效率高，传输数据大的则使用批量传输端点。</p>
<p>端点具有方向性，中断端点一般是输入的。批量传输一般需要输入和输出两个端点。</p>
<p>数据传输的通道叫做管道。端点是传输地址，管道是传输路径。</p>
<p>数据传输由一个urb结构对象来管理，使用者只需要申请设置好urb，然后提交给usb核心，由usb核心调度数据传输，当数据传输完成时调用usr对象中设置的回调函数。</p>
<p>以usbmouse驱动为例说明驱动功能的主要步骤。</p>
<p>1.获取端点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">endpoint = &amp;interface-&gt;endpoint[0].desc;</span><br><span class="line">	if (!usb_endpoint_is_int_in(endpoint))</span><br><span class="line">		return -ENODEV;</span><br></pre></td></tr></table></figure>
<p>2.创建管道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipe = usb_rcvintpipe(dev, endpoint-&gt;bEndpointAddress);</span><br></pre></td></tr></table></figure>
<p>3.申请传输数据空间，这里申请了dma空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mouse-&gt;data = usb_alloc_coherent(dev, 8, GFP_ATOMIC, &amp;mouse-&gt;data_dma);</span><br></pre></td></tr></table></figure>
<p>4.申请urb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mouse-&gt;irq = usb_alloc_urb(0, GFP_KERNEL);</span><br></pre></td></tr></table></figure>
<p>5.设置urb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usb_fill_int_urb(mouse-&gt;irq, dev, pipe, mouse-&gt;data,</span><br><span class="line">		 (maxp &gt; 8 ? 8 : maxp),</span><br><span class="line">		 usb_mouse_irq, mouse, endpoint-&gt;bInterval);</span><br></pre></td></tr></table></figure>
<p>这里usb使用的是中断输入端点，所以在urb设置的回调函数usb_mouse_irq中需要重新提交urb以进行循环轮询。</p>
<p>6.提交urb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usb_submit_urb(mouse-&gt;irq, GFP_KERNEL)</span><br></pre></td></tr></table></figure>
<p>在usb鼠标驱动中，是在usbmouse设备文件的open函数中提交urb的。</p>
<p>以上就是一个usb中断传输的驱动程序usb功能实现部分，其他传输端点类似。</p>
</div><div class="tags"><a href="/tags/Linux/">Linux</a><a href="/tags/kernel/">kernel</a><a href="/tags/usb/">usb</a></div><div class="post-nav"><a class="pre" href="/2019/07/28/hello-world/">Hello World</a><a class="next" href="/2019/06/09/Linux内核initcall过程/">Linux内核initcall过程</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  id: window.location.pathname.substring(1,window.location.pathname.length),
  owner: 'geekchenxd',
  repo: 'geekchenxd.github.io',
  oauth: {
    client_id: '00f3259791ebc5b5d412',
    client_secret: 'd88056bc0050337d5767e26f8d228f526ed7687d',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://www.chenxd.xyz"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel/">Kernel</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/qemu/">qemu</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/dts/" style="font-size: 15px;">dts</a> <a href="/tags/subsystem/" style="font-size: 15px;">subsystem</a> <a href="/tags/notification/" style="font-size: 15px;">notification</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/Debug/" style="font-size: 15px;">Debug</a> <a href="/tags/file-system/" style="font-size: 15px;">file_system</a> <a href="/tags/dtb/" style="font-size: 15px;">dtb</a> <a href="/tags/initcall/" style="font-size: 15px;">initcall</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/Interrupt/" style="font-size: 15px;">Interrupt</a> <a href="/tags/watchdog/" style="font-size: 15px;">watchdog</a> <a href="/tags/arm/" style="font-size: 15px;">arm</a> <a href="/tags/usb/" style="font-size: 15px;">usb</a> <a href="/tags/device-driver/" style="font-size: 15px;">device driver</a> <a href="/tags/mdio/" style="font-size: 15px;">mdio</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/06/21/Linux内核mdio子系统/">Linux内核mdio子系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/06/ARM-LINUX根文件系统移植/">ARM-LINUX根文件系统移植</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/05/Linux内核调试之KGDB/">Linux内核调试之KGDB</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/Linux内核设备驱动模型/">Linux内核设备驱动模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/Qemu虚拟Arm开发板/">Qemu虚拟Arm开发板</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/Linux内核通知链/">Linux内核通知链</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/26/ARM-LINUX中断系统/">ARM-LINUX中断系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/25/Linux内核之看门狗子系统/">Linux内核之看门狗子系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/24/Linux内核之虚拟文件系统/">Linux内核之虚拟文件系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/28/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.github.com" title="github" target="_blank">github</a><ul></ul><a href="http://www.kernel.org" title="linux kernel" target="_blank">linux kernel</a><ul></ul><a href="http://www.combatpress.com/" title="Combat Press" target="_blank">Combat Press</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Evil Code.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>