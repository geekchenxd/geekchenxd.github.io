<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Code controls all the hardware"><title>Linux内核usb子系统 | Evil Code</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux内核usb子系统</h1><a id="logo" href="/.">Evil Code</a><p class="description">Coding Change The World</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux内核usb子系统</h1><div class="post-meta">Jun 9, 2019<span> | </span><span class="category"><a href="/categories/Kernel/">Kernel</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#说明"><span class="toc-number">1.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USB子系统"><span class="toc-number">2.</span> <span class="toc-text">USB子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化usb的debugfs"><span class="toc-number">2.1.</span> <span class="toc-text">初始化usb的debugfs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注册usb的acpi总线"><span class="toc-number">2.2.</span> <span class="toc-text">注册usb的acpi总线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注册usb总线"><span class="toc-number">2.3.</span> <span class="toc-text">注册usb总线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注册usb总线通知链"><span class="toc-number">2.4.</span> <span class="toc-text">注册usb总线通知链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注册usb设备字符设备主设备"><span class="toc-number">2.5.</span> <span class="toc-text">注册usb设备字符设备主设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注册usbfs"><span class="toc-number">2.6.</span> <span class="toc-text">注册usbfs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注册usb字符设备"><span class="toc-number">2.7.</span> <span class="toc-text">注册usb字符设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化hub"><span class="toc-number">2.8.</span> <span class="toc-text">初始化hub</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注册usb-generic-driver"><span class="toc-number">2.9.</span> <span class="toc-text">注册usb_generic_driver</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USB-hub驱动"><span class="toc-number">3.</span> <span class="toc-text">USB hub驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hub-probe函数"><span class="toc-number">3.1.</span> <span class="toc-text">hub_probe函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hub-irq函数"><span class="toc-number">3.2.</span> <span class="toc-text">hub_irq函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hub-event函数"><span class="toc-number">3.3.</span> <span class="toc-text">hub_event函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#usb-hub驱动总结"><span class="toc-number">3.4.</span> <span class="toc-text">usb hub驱动总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USB接口驱动"><span class="toc-number">4.</span> <span class="toc-text">USB接口驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#usbmouse的注册"><span class="toc-number">4.1.</span> <span class="toc-text">usbmouse的注册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#usbmouse的probe函数"><span class="toc-number">4.2.</span> <span class="toc-text">usbmouse的probe函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#usbmouse的usb-mouse-irq函数"><span class="toc-number">4.3.</span> <span class="toc-text">usbmouse的usb_mouse_irq函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#usb接口驱动总结"><span class="toc-number">4.4.</span> <span class="toc-text">usb接口驱动总结</span></a></li></ol></li></ol></div></div><div class="post-content"><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>​    本文通过linux内核代码分析usb子系统的整体框架，所使用的内核版本为linux5.0.5，侧重点在与hub驱动和usb接口驱动，而我们平常关心的主要是usb接口驱动，hub驱动是通用的驱动程序，负责识别物理设备，并为物理设备查找usb接口驱动。针对不同的usb设备，驱动开发者关心的是接口驱动，不同的设备需要实现不同的接口驱动来使设备正常运行。</p>
<h3 id="USB子系统"><a href="#USB子系统" class="headerlink" title="USB子系统"></a>USB子系统</h3><p>usb子系统主要功能通过usb子系统初始化过程可以大体得知。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">usb_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="keyword">if</span> (usb_disabled()) &#123;</span><br><span class="line">		pr_info(<span class="string">"%s: USB support disabled\n"</span>, usbcore_name);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	usb_init_pool_max();</span><br><span class="line"></span><br><span class="line">	usb_debugfs_init();</span><br><span class="line"></span><br><span class="line">	usb_acpi_register();</span><br><span class="line">	retval = bus_register(&amp;usb_bus_type);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bus_register_failed;</span><br><span class="line">	retval = bus_register_notifier(&amp;usb_bus_type, &amp;usb_bus_nb);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bus_notifier_failed;</span><br><span class="line">	retval = usb_major_init();</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> major_init_failed;</span><br><span class="line">	retval = usb_register(&amp;usbfs_driver);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> driver_register_failed;</span><br><span class="line">	retval = usb_devio_init();</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> usb_devio_init_failed;</span><br><span class="line">	retval = usb_hub_init();</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> hub_init_failed;</span><br><span class="line">	retval = usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE);</span><br><span class="line">	<span class="keyword">if</span> (!retval)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	usb_hub_cleanup();</span><br><span class="line">hub_init_failed:</span><br><span class="line">	usb_devio_cleanup();</span><br><span class="line">usb_devio_init_failed:</span><br><span class="line">	usb_deregister(&amp;usbfs_driver);</span><br><span class="line">driver_register_failed:</span><br><span class="line">	usb_major_cleanup();</span><br><span class="line">major_init_failed:</span><br><span class="line">	bus_unregister_notifier(&amp;usb_bus_type, &amp;usb_bus_nb);</span><br><span class="line">bus_notifier_failed:</span><br><span class="line">	bus_unregister(&amp;usb_bus_type);</span><br><span class="line">bus_register_failed:</span><br><span class="line">	usb_acpi_unregister();</span><br><span class="line">	usb_debugfs_cleanup();</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>usb子系统的初始化大概流程如下</p>
<h4 id="初始化usb的debugfs"><a href="#初始化usb的debugfs" class="headerlink" title="初始化usb的debugfs"></a>初始化usb的debugfs</h4><p>创建usb的debugfs，可在跟文件系统中通过mount命令来挂载debugfs，并用来调试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usb_debugfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	usb_debug_root = debugfs_create_dir(<span class="string">"usb"</span>, <span class="literal">NULL</span>);</span><br><span class="line">	debugfs_create_file(<span class="string">"devices"</span>, <span class="number">0444</span>, usb_debug_root, <span class="literal">NULL</span>,</span><br><span class="line">			    &amp;usbfs_devices_fops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注册usb的acpi总线"><a href="#注册usb的acpi总线" class="headerlink" title="注册usb的acpi总线"></a>注册usb的acpi总线</h4><h4 id="注册usb总线"><a href="#注册usb总线" class="headerlink" title="注册usb总线"></a>注册usb总线</h4><p>usb注册的总线初始化如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">usb_bus_type</span> = &#123;</span></span><br><span class="line">	.name =		<span class="string">"usb"</span>,</span><br><span class="line">	.match =	usb_device_match,</span><br><span class="line">	.uevent =	usb_uevent,</span><br><span class="line">	.need_parent_lock =	<span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中.match函数用来匹配驱动和设备（接口）</p>
<p>.uevent是usb事件处理函数</p>
<p>在usb_device_match函数中区分设备和接口做不同的处理，如果是设备类型，直接匹配成功。如果是接口，则根据接口驱动的id_table成员匹配。接口驱动的注册在后面usb接口驱动章节说明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">usb_device_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* devices and interfaces are handled separately */</span></span><br><span class="line">	<span class="keyword">if</span> (is_usb_device(dev)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* interface drivers never match devices */</span></span><br><span class="line">		<span class="keyword">if</span> (!is_usb_device_driver(drv))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* <span class="doctag">TODO:</span> Add real matching code */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_usb_interface(dev)) &#123;</span><br><span class="line">		struct usb_interface *intf;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> *<span class="title">usb_drv</span>;</span></span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* device drivers never match interfaces */</span></span><br><span class="line">		<span class="keyword">if</span> (is_usb_device_driver(drv))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		intf = to_usb_interface(dev);</span><br><span class="line">		usb_drv = to_usb_driver(drv);</span><br><span class="line"></span><br><span class="line">		id = usb_match_id(intf, usb_drv-&gt;id_table);</span><br><span class="line">		<span class="keyword">if</span> (id)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		id = usb_match_dynamic_id(intf, usb_drv);</span><br><span class="line">		<span class="keyword">if</span> (id)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：usb总线上既有usb设备驱动，又有usb接口驱动，匹配时再根据类型区分，我们通常关心的usb物理设备（比如usb鼠标）绑定的是usb接口驱动。</p>
<h4 id="注册usb总线通知链"><a href="#注册usb总线通知链" class="headerlink" title="注册usb总线通知链"></a>注册usb总线通知链</h4><p>主要用来设置回调函数处理其他子系统的通知，usb子系统注册的notifier_block如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">usb_bus_nb</span> = &#123;</span></span><br><span class="line">	.notifier_call = usb_bus_notify,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>usb_bus_notify回调函数根据不同的通知类型处理，通知类型为添加设备和删除设备。不同的通知类型再根据设备类型是接口还是设备在sysfs下添加或移除设备或接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Notifications of device and interface registration</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">usb_bus_notify</span><span class="params">(struct notifier_block *nb, <span class="keyword">unsigned</span> <span class="keyword">long</span> action,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> = <span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">	<span class="keyword">case</span> BUS_NOTIFY_ADD_DEVICE:</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;type == &amp;usb_device_type)</span><br><span class="line">			(<span class="keyword">void</span>) usb_create_sysfs_dev_files(to_usb_device(dev));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;type == &amp;usb_if_device_type)</span><br><span class="line">			usb_create_sysfs_intf_files(to_usb_interface(dev));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> BUS_NOTIFY_DEL_DEVICE:</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;type == &amp;usb_device_type)</span><br><span class="line">			usb_remove_sysfs_dev_files(to_usb_device(dev));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;type == &amp;usb_if_device_type)</span><br><span class="line">			usb_remove_sysfs_intf_files(to_usb_interface(dev));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注册usb设备字符设备主设备"><a href="#注册usb设备字符设备主设备" class="headerlink" title="注册usb设备字符设备主设备"></a>注册usb设备字符设备主设备</h4><p>注册usb设备字符设备驱动的主设备，主设备号为180</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usb_major_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	error = register_chrdev(USB_MAJOR, <span class="string">"usb"</span>, &amp;usb_fops);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		printk(KERN_ERR <span class="string">"Unable to get major %d for usb devices\n"</span>,</span><br><span class="line">		       USB_MAJOR);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注册usbfs"><a href="#注册usbfs" class="headerlink" title="注册usbfs"></a>注册usbfs</h4><p>注册usb文件系统。</p>
<h4 id="注册usb字符设备"><a href="#注册usb字符设备" class="headerlink" title="注册usb字符设备"></a>注册usb字符设备</h4><p>添加usb字符设备，主设备的初始化在前面第5节完成。</p>
<h4 id="初始化hub"><a href="#初始化hub" class="headerlink" title="初始化hub"></a>初始化hub</h4><p>在usb_hub_init函数中做了两件事，一是注册了hub的接口驱动，二是申请了hub的workqueue。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usb_hub_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (usb_register(&amp;hub_driver) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">"%s: can't register hub driver\n"</span>,</span><br><span class="line">			usbcore_name);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The workqueue needs to be freezable to avoid interfering with</span></span><br><span class="line"><span class="comment">	 * USB-PERSIST port handover. Otherwise it might see that a full-speed</span></span><br><span class="line"><span class="comment">	 * device was gone before the EHCI controller had handed its port</span></span><br><span class="line"><span class="comment">	 * over to the companion full-speed controller.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	hub_wq = alloc_workqueue(<span class="string">"usb_hub_wq"</span>, WQ_FREEZABLE, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hub_wq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fall through if kernel_thread failed */</span></span><br><span class="line">	usb_deregister(&amp;hub_driver);</span><br><span class="line">	pr_err(<span class="string">"%s: can't allocate workqueue for usb hub\n"</span>, usbcore_name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>usb_register（注册接口驱动）宏在内核中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* use a define to avoid include chaining to get THIS_MODULE &amp; friends */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> usb_register(driver) \</span></span><br><span class="line">	usb_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)</span><br></pre></td></tr></table></figure>
<p>usb_register_driver函数事实上向usb总线注册了struct device_driver的驱动，并且在sysfs下创建了hub驱动的文件，内核代码片段如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">new_driver-&gt;drvwrap.for_devices = <span class="number">0</span>;</span><br><span class="line">new_driver-&gt;drvwrap.driver.name = new_driver-&gt;name;</span><br><span class="line">new_driver-&gt;drvwrap.driver.bus = &amp;usb_bus_type;</span><br><span class="line">new_driver-&gt;drvwrap.driver.probe = usb_probe_interface;</span><br><span class="line">new_driver-&gt;drvwrap.driver.remove = usb_unbind_interface;</span><br><span class="line">new_driver-&gt;drvwrap.driver.owner = owner;</span><br><span class="line">new_driver-&gt;drvwrap.driver.mod_name = mod_name;</span><br><span class="line">spin_lock_init(&amp;new_driver-&gt;dynids.lock);</span><br><span class="line">INIT_LIST_HEAD(&amp;new_driver-&gt;dynids.<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">retval = driver_register(&amp;new_driver-&gt;drvwrap.driver);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">retval = usb_create_newid_files(new_driver);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> out_newid;</span><br></pre></td></tr></table></figure>
<p>从以上代码可以看到注册的struct device_driver驱动在hub_driver的drvwrap成员中，该成员定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct usbdrv_wrap - wrapper for driver-model structure</span></span><br><span class="line"><span class="comment"> * @driver: The driver-model core driver structure.</span></span><br><span class="line"><span class="comment"> * @for_devices: Non-zero for device drivers, 0 for interface drivers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usbdrv_wrap</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">	<span class="keyword">int</span> for_devices;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中driver成员就是向usb总线注册的接口驱动，for_devices成员用来区分该驱动是接口还是设备。0表示接口，非0表示设备，在这里注册为接口驱动。其probe函数为usb_probe_interface.这里注册device驱动的时候，会在usb总线上匹配驱动，匹配过程在注册usb总线一节已经说明，匹配成功后就会调用到usb_probe_interface。在这里补充说明一点，usb总线匹配函数根据usb_driver的id_table成员匹配，而我们注册的是device_driver驱动，所以在匹配的时候先通过device_drv找到usb_driver，然后再根据usb_driver的id_table成员匹配，该部分代码片段如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">usb_drv = to_usb_driver(drv);</span><br><span class="line"></span><br><span class="line">id = usb_match_id(intf, usb_drv-&gt;id_table);</span><br><span class="line"><span class="keyword">if</span> (id)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>其中to_usb_driver宏函数的实现为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	to_usb_driver(d) container_of(d, struct usb_driver, drvwrap.driver)</span></span><br></pre></td></tr></table></figure>
<p>到这里就完成了hub_driver驱动的注册，再看hub_driver的初始化代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">hub_driver</span> = &#123;</span></span><br><span class="line">	.name =		<span class="string">"hub"</span>,</span><br><span class="line">	.probe =	hub_probe,</span><br><span class="line">	.disconnect =	hub_disconnect,</span><br><span class="line">	.suspend =	hub_suspend,</span><br><span class="line">	.resume =	hub_resume,</span><br><span class="line">	.reset_resume =	hub_reset_resume,</span><br><span class="line">	.pre_reset =	hub_pre_reset,</span><br><span class="line">	.post_reset =	hub_post_reset,</span><br><span class="line">	.unlocked_ioctl = hub_ioctl,</span><br><span class="line">	.id_table =	hub_id_table,</span><br><span class="line">	.supports_autosuspend =	<span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这里关心两个问题1.hub_probe是如何调用的？2.hub_probe做了啥？</p>
<p>对于第一个问题，答案是在usb_probe_interface函数中调用了hub_probe函数，前面分析到注册hub_driver时真正注册到总线的是hub_driver的drvwrap成员的driver成员，向usb总线注册hub_driver.drvwrap.driver时，根据hub_driver的idtable成员匹配，匹配成功后调用hub_driver.drvwrap.driver.probe，即usb_probe_interface，在usb_probe_interface函数中在反过来调用到hub_probe函数。该部分代码在usb_probe_interface中体现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error = driver-&gt;probe(intf, id);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br></pre></td></tr></table></figure>
<p>第二个问题在第四章usb hub驱动中解答</p>
<h4 id="注册usb-generic-driver"><a href="#注册usb-generic-driver" class="headerlink" title="注册usb_generic_driver"></a>注册usb_generic_driver</h4><p>首先看注册函数usb_register_device_driver</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * usb_register_device_driver - register a USB device (not interface) driver</span></span><br><span class="line"><span class="comment"> * @new_udriver: USB operations for the device driver</span></span><br><span class="line"><span class="comment"> * @owner: module owner of this driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Registers a USB device driver with the USB core.  The list of</span></span><br><span class="line"><span class="comment"> * unattached devices will be rescanned whenever a new driver is</span></span><br><span class="line"><span class="comment"> * added, allowing the new driver to attach to any recognized devices.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: A negative error code on failure and 0 on success.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usb_register_device_driver</span><span class="params">(struct usb_device_driver *new_udriver,</span></span></span><br><span class="line"><span class="function"><span class="params">		struct <span class="keyword">module</span> *owner)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (usb_disabled())</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	new_udriver-&gt;drvwrap.for_devices = <span class="number">1</span>;</span><br><span class="line">	new_udriver-&gt;drvwrap.driver.name = new_udriver-&gt;name;</span><br><span class="line">	new_udriver-&gt;drvwrap.driver.bus = &amp;usb_bus_type;</span><br><span class="line">	new_udriver-&gt;drvwrap.driver.probe = usb_probe_device;</span><br><span class="line">	new_udriver-&gt;drvwrap.driver.remove = usb_unbind_device;</span><br><span class="line">	new_udriver-&gt;drvwrap.driver.owner = owner;</span><br><span class="line"></span><br><span class="line">	retval = driver_register(&amp;new_udriver-&gt;drvwrap.driver);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!retval)</span><br><span class="line">		pr_info(<span class="string">"%s: registered new device driver %s\n"</span>,</span><br><span class="line">			usbcore_name, new_udriver-&gt;name);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		printk(KERN_ERR <span class="string">"%s: error %d registering device "</span></span><br><span class="line">			<span class="string">"	driver %s\n"</span>,</span><br><span class="line">			usbcore_name, retval, new_udriver-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与usb_register_driver过程类似，usb_register_device_driver函数向usb总线注册了一个设备驱动（非接口驱动）。在前面分析到总线的match函数中，对于设备驱动，直接返回匹配成功，匹配成功后调用usb_probe_device函数，在usb_probe_device函数中调用usb_generic_driver的probe函数。usb_generic_driver初始化代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device_driver</span> <span class="title">usb_generic_driver</span> = &#123;</span></span><br><span class="line">	.name =	<span class="string">"usb"</span>,</span><br><span class="line">	.probe = generic_probe,</span><br><span class="line">	.disconnect = generic_disconnect,</span><br><span class="line">#ifdef	CONFIG_PM</span><br><span class="line">	.suspend = generic_suspend,</span><br><span class="line">	.resume = generic_resume,</span><br><span class="line">#endif</span><br><span class="line">	.supports_autosuspend = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这里usb_generic_driver是一个usb通用设备驱动，所有的usb设备（非接口）都会匹配到该驱动，然后调用到generic_probe函数。该probe函数为usb设备选择并设置一个配置，然后通知usb子系统添加设备，即最终调用到前面章节注册通知链设置的回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">generic_probe</span><span class="params">(struct usb_device *udev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err, c;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Choose and set the configuration.  This registers the interfaces</span></span><br><span class="line"><span class="comment">	 * with the driver core and lets interface drivers bind to them.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (udev-&gt;authorized == <span class="number">0</span>)</span><br><span class="line">		dev_err(&amp;udev-&gt;dev, <span class="string">"Device is not authorized for usage\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		c = usb_choose_configuration(udev);</span><br><span class="line">		<span class="keyword">if</span> (c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			err = usb_set_configuration(udev, c);</span><br><span class="line">			<span class="keyword">if</span> (err &amp;&amp; err != -ENODEV) &#123;</span><br><span class="line">				dev_err(&amp;udev-&gt;dev, <span class="string">"can't set config #%d, error %d\n"</span>,</span><br><span class="line">					c, err);</span><br><span class="line">				<span class="comment">/* This need not be fatal.  The user can try to</span></span><br><span class="line"><span class="comment">				 * set other configurations. */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* USB device state == configured ... usable */</span></span><br><span class="line">	usb_notify_add_device(udev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从generic_probe函数可知，generic驱动的主要功能就是调用usb_set_configuration函数为该usb设备的所有接口设备申请空间和初始化，然后注册到系统设备驱动模型中。当这些接口设备被注册到usb总线上的时候，将会为接口设备匹配相应的usb接口驱动。</p>
<p>以上所初始化的就是usb子系统的主要功能模块。</p>
<h3 id="USB-hub驱动"><a href="#USB-hub驱动" class="headerlink" title="USB hub驱动"></a>USB hub驱动</h3><h4 id="hub-probe函数"><a href="#hub-probe函数" class="headerlink" title="hub_probe函数"></a>hub_probe函数</h4><p>在hub_probe函数中主要做初始化和配置hub的工作，在这里关心下初始化事件处理任务，任务处理是本章分析的重点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INIT_WORK(&amp;hub-&gt;events, hub_event);</span><br></pre></td></tr></table></figure>
<p>接着对hub进行了配置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hub_configure(hub, endpoint) &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>在hub_configure函数中申请了urb结构，urb是usb数据传输的核心结构，usb主机和设备的通信都是通过urb来组织传输的。每次数据传输都是向usb核心提交一个urb。结合hub_configure分析urb的一般使用过程如下:</p>
<p>a.申请urb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hub-&gt;urb = usb_alloc_urb(0, GFP_KERNEL);</span><br><span class="line">if (!hub-&gt;urb) &#123;</span><br><span class="line">	ret = -ENOMEM;</span><br><span class="line">	goto fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>b.设置urb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usb_fill_int_urb(hub-&gt;urb, hdev, pipe, *hub-&gt;buffer, maxp, hub_irq,</span><br><span class="line">		hub, endpoint-&gt;bInterval);</span><br></pre></td></tr></table></figure>
<p>在设置urb的时候传入了hub_irq回调函数,该回调和中断处理有所差别,usb是严格的主从设备,从设备只能响应主设备,所有数据都是由主设备发起的,所以该中断回调意思是主设备不停的向从设备询问,当从设备回复了数据后调用该回调函数.</p>
<p>c.使用urb</p>
<p>在这里urb的使用是在hub_activate函数中,当hub_configure完成的时候调用hub_activate函数进一步初始化hub.并在最后向usb核心提交了urb.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">status = usb_submit_urb(hub-&gt;urb, GFP_NOIO);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">		dev_err(hub-&gt;intfdev, <span class="string">"activate --&gt; %d\n"</span>, status);</span><br></pre></td></tr></table></figure>
<h4 id="hub-irq函数"><a href="#hub-irq函数" class="headerlink" title="hub_irq函数"></a>hub_irq函数</h4><p>在hub_irq中主要完成两件工作,一是调用kick_hub_wq函数,二是重新提交urb,对于中断传输方式的urb,在其回调函数中必须重新提交urb,以循环主设备查询。在这里我们重点看下kick_hub_wq函数做了什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kick_hub_wq</span><span class="params">(struct usb_hub *hub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_interface</span> *<span class="title">intf</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hub-&gt;disconnected || work_pending(&amp;hub-&gt;events))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Suppress autosuspend until the event is proceed.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Be careful and make sure that the symmetric operation is</span></span><br><span class="line"><span class="comment">	 * always called. We are here only when there is no pending</span></span><br><span class="line"><span class="comment">	 * work for this hub. Therefore put the interface either when</span></span><br><span class="line"><span class="comment">	 * the new work is called or when it is canceled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	intf = to_usb_interface(hub-&gt;intfdev);</span><br><span class="line">	usb_autopm_get_interface_no_resume(intf);</span><br><span class="line">	kref_get(&amp;hub-&gt;kref);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queue_work(hub_wq, &amp;hub-&gt;events))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the work has already been scheduled */</span></span><br><span class="line">	usb_autopm_put_interface_async(intf);</span><br><span class="line">	kref_put(&amp;hub-&gt;kref, hub_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过阅读以上代码可以看出，kick_hub_wq函数主要工作就是向hub工作队列中添加任务，在前面hub_probe的时候我们分析到hub-&gt;events任务绑定的回调函数是hub_event。hub_wq也在hub_probe中做了初始化。hub工作队列会回调到hub_event函数。hub_event是hub驱动的核心部分，我们将在下面的小节中分析。</p>
<h4 id="hub-event函数"><a href="#hub-event函数" class="headerlink" title="hub_event函数"></a>hub_event函数</h4><p>省去复杂的代码，只看核心流程，hub_event函数中对hub的所有port调用port_event函数进行状态变化处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* deal with port status changes */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= hdev-&gt;maxchild; i++) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_port</span> *<span class="title">port_dev</span> = <span class="title">hub</span>-&gt;<span class="title">ports</span>[<span class="title">i</span> - 1];</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (test_bit(i, hub-&gt;event_bits)</span><br><span class="line">			|| test_bit(i, hub-&gt;change_bits)</span><br><span class="line">			|| test_bit(i, hub-&gt;wakeup_bits)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The get_noresume and barrier ensure that if</span></span><br><span class="line"><span class="comment">		 * the port was in the process of resuming, we</span></span><br><span class="line"><span class="comment">		 * flush that work and keep the port active for</span></span><br><span class="line"><span class="comment">		 * the duration of the port_event().  However,</span></span><br><span class="line"><span class="comment">		 * if the port is runtime pm suspended</span></span><br><span class="line"><span class="comment">		 * (powered-off), we leave it in that state, run</span></span><br><span class="line"><span class="comment">		 * an abbreviated port_event(), and move on.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		pm_runtime_get_noresume(&amp;port_dev-&gt;dev);</span><br><span class="line">		pm_runtime_barrier(&amp;port_dev-&gt;dev);</span><br><span class="line">		usb_lock_port(port_dev);</span><br><span class="line">		port_event(hub, i);</span><br><span class="line">		usb_unlock_port(port_dev);</span><br><span class="line">		pm_runtime_put_sync(&amp;port_dev-&gt;dev);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在port_event函数中判断有物理设备或逻辑设备连接事件（比如插入了一个优盘）就调用hub_port_connect_change函数进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (connect_change)</span><br><span class="line">		hub_port_connect_change(hub, port1, portstatus, portchange);</span><br></pre></td></tr></table></figure>
<p>在hub_port_connect_change函数中调用hub_port_connect函数真正处理连接事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usb_unlock_port(port_dev);</span><br><span class="line">hub_port_connect(hub, port1, portstatus, portchange);</span><br><span class="line">usb_lock_port(port_dev);</span><br></pre></td></tr></table></figure>
<p>接下来看看hub_port_connect函数，阅读其代码可知hub_port_connect函数主要有以下三个工作：</p>
<p>a.申请usb_device</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">udev = usb_alloc_dev(hdev, hdev-&gt;bus, port1);</span><br><span class="line"><span class="keyword">if</span> (!udev) &#123;</span><br><span class="line">	dev_err(&amp;port_dev-&gt;dev,</span><br><span class="line">			<span class="string">"couldn't allocate usb_device\n"</span>);</span><br><span class="line">	<span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>b.为usb_device选择一个地址编号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">choose_devnum(udev);</span><br><span class="line"><span class="keyword">if</span> (udev-&gt;devnum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">	status = -ENOTCONN;	<span class="comment">/* Don't retry */</span></span><br><span class="line">	<span class="keyword">goto</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c.调用usb_port_init函数初始化usb_device</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset (non-USB 3.0 devices) and get descriptor */</span></span><br><span class="line">usb_lock_port(port_dev);</span><br><span class="line">status = hub_port_init(hub, udev, port1, i);</span><br><span class="line">usb_unlock_port(port_dev);</span><br></pre></td></tr></table></figure>
<p>继续阅读hub_port_init函数的代码，在hub_port_init函数中区分两种设备类型，一种是new scheme，一种自然是old scheme，关于这两种的区别在这里简单说明，new scheme是微软的方式，而old scheme是Linux的方式，这两种方式的区别在于new scheme获取设备描述符的时候一次返回整个描述符，在驱动中如果端点0的max packet size（规定的最小的max packet size是8，可以是8，16，32，64，该参数的值在设备描述符的第8个字节中）足够设备描述符的大小18个字节，则一次读取完成，如果端点0的max packet size不够设备描述符的大小，设备需要分多次传输，此时只要接收到前8个字节，就直接复位设备，停止其他数据的传输了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (operations = <span class="number">0</span>; operations &lt; <span class="number">3</span>; ++operations) &#123;</span><br><span class="line">	buf-&gt;bMaxPacketSize0 = <span class="number">0</span>;</span><br><span class="line">	r = usb_control_msg(udev, usb_rcvaddr0pipe(),</span><br><span class="line">		USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,</span><br><span class="line">		USB_DT_DEVICE &lt;&lt; <span class="number">8</span>, <span class="number">0</span>,</span><br><span class="line">		buf, GET_DESCRIPTOR_BUFSIZE,</span><br><span class="line">		initial_descriptor_timeout);</span><br><span class="line">	<span class="keyword">switch</span> (buf-&gt;bMaxPacketSize0) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">8</span>: <span class="keyword">case</span> <span class="number">16</span>: <span class="keyword">case</span> <span class="number">32</span>: <span class="keyword">case</span> <span class="number">64</span>: <span class="keyword">case</span> <span class="number">255</span>:</span><br><span class="line">		<span class="keyword">if</span> (buf-&gt;bDescriptorType ==</span><br><span class="line">				USB_DT_DEVICE) &#123;</span><br><span class="line">			r = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* FALL THROUGH */</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">			r = -EPROTO;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Some devices time out if they are powered on</span></span><br><span class="line"><span class="comment">	 * when already connected. They need a second</span></span><br><span class="line"><span class="comment">	 * reset. But only on the first attempt,</span></span><br><span class="line"><span class="comment">	 * lest we get into a time out/reset loop</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (r == <span class="number">0</span>  || (r == -ETIMEDOUT &amp;&amp; retries == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">udev-&gt;descriptor.bMaxPacketSize0 =</span><br><span class="line">		buf-&gt;bMaxPacketSize0;</span><br><span class="line">kfree(buf);</span><br><span class="line"></span><br><span class="line">retval = hub_port_reset(hub, port1, udev, delay, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>对于old scheme的设备，设备一次可以只返回前8个字节的设备描述符，在不知道端点max packet size的时候，只读8个字节长度的设备描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">retval = usb_get_device_descriptor(udev, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (retval != -ENODEV)</span><br><span class="line">        dev_err(&amp;udev-&gt;dev,</span><br><span class="line">                <span class="string">"device descriptor read/8, error %d\n"</span>,</span><br><span class="line">                retval);</span><br><span class="line">    <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">        retval = -EMSGSIZE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    retval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面不同的方式读取完设备描述符的至少前8个字节后，根据前8个字节设置usb设备的相应属性，然后接着读取完整的设备描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retval = usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE);</span><br></pre></td></tr></table></figure>
<p>至此，usb_port_init函数结束，继续接着分析hub_port_connect函数。</p>
<p>d.调用接口usb_new_device创建usb设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status = usb_new_device(udev);</span><br></pre></td></tr></table></figure>
<p>下面分析usb_new_device函数主要做了什么</p>
<p>1.调用usb_enumerate_device枚举usb设备</p>
<p>在usb_enumerate_device函数中调用usb_get_configuration获取和解析配置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = usb_get_configuration(udev);</span><br></pre></td></tr></table></figure>
<p>在usb_get_configuration中首先通过usb_get_descriptor接口获取usb设备的设备描述符，然后调用usb_parse_configuration接口解析配置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = usb_parse_configuration(dev, cfgno,</span><br><span class="line">		    &amp;dev-&gt;config[cfgno], bigbuffer, length);</span><br></pre></td></tr></table></figure>
<p>2.设置字符设备，在device_add的时候创建设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* export the usbdev device-node for libusb */</span></span><br><span class="line">udev-&gt;dev.devt = MKDEV(USB_DEVICE_MAJOR,</span><br><span class="line">		(((udev-&gt;bus-&gt;busnum<span class="number">-1</span>) * <span class="number">128</span>) + (udev-&gt;devnum<span class="number">-1</span>)));</span><br></pre></td></tr></table></figure>
<p>3.向usb总线注册设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Register the device.  The device driver is responsible</span></span><br><span class="line"><span class="comment">* for configuring the device and invoking the add-device</span></span><br><span class="line"><span class="comment">* notifier chain (used by usbfs and possibly others).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">err = device_add(&amp;udev-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">	dev_err(&amp;udev-&gt;dev, <span class="string">"can't device_add, error %d\n"</span>, err);</span><br><span class="line">	<span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在device_add调用里调用bus_add_device将设备添加到usb总线，并调用usb的通知回调，然后调用bus_probe_device接口匹配usb驱动，并执行驱动的probe函数（generic_probe）。在usb设备驱动的probe函数中再注册其usb接口设备。到此为止，就完成了一个usb添加事件。</p>
<h4 id="usb-hub驱动总结"><a href="#usb-hub驱动总结" class="headerlink" title="usb hub驱动总结"></a>usb hub驱动总结</h4><p>通过前面小节的分析得知usb hub驱动完成的工作为通用的设备驱动，每个新接入的usb设备都通过hub驱动来枚举，之后为新设备从总线上匹配合适的驱动，剩下的工作就交给具体的设备（接口）驱动完成了。以下为usb_hub驱动工作的总结：</p>
<p>a.负责监测端口变化</p>
<p>b.为新设备申请usb_device</p>
<p>c.为新设备分配地址</p>
<p>d.获取和解析新设备的描述符</p>
<p>e.设备枚举</p>
<p>f.向usb总线添加新设备，在添加的时候为新设备匹配驱动</p>
<h3 id="USB接口驱动"><a href="#USB接口驱动" class="headerlink" title="USB接口驱动"></a>USB接口驱动</h3><p>usb接口驱动是我们真正关心的设备驱动，通过上一章节我们知道接入一个新的usb设备，首先由hub驱动完成其枚举工作，然后在总线上为其匹配合适的驱动，就是本章节要讲的usb接口驱动，本章节以内核usb_mouse为例说明。</p>
<h4 id="usbmouse的注册"><a href="#usbmouse的注册" class="headerlink" title="usbmouse的注册"></a>usbmouse的注册</h4><p>usbmouse入口如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module_usb_driver(usb_mouse_driver);</span><br></pre></td></tr></table></figure>
<p>module_usb_driver宏以及相关宏在内核中定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * use these in module_init()/module_exit()</span></span><br><span class="line"><span class="comment"> * and don't forget MODULE_DEVICE_TABLE(usb, ...)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">usb_register_driver</span><span class="params">(struct usb_driver *, struct <span class="keyword">module</span> *,</span></span></span><br><span class="line"><span class="function"><span class="params">			       <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* use a define to avoid include chaining to get THIS_MODULE &amp; friends */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> usb_register(driver) \</span></span><br><span class="line">	usb_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">usb_deregister</span><span class="params">(struct usb_driver *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * module_usb_driver() - Helper macro for registering a USB driver</span></span><br><span class="line"><span class="comment"> * @__usb_driver: usb_driver struct</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Helper macro for USB drivers which do not do anything special in module</span></span><br><span class="line"><span class="comment"> * init/exit. This eliminates a lot of boilerplate. Each module may only</span></span><br><span class="line"><span class="comment"> * use this macro once, and calling it replaces module_init() and module_exit()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> module_usb_driver(__usb_driver) \</span></span><br><span class="line">	module_driver(__usb_driver, usb_register, \</span><br><span class="line">		       usb_deregister)</span><br></pre></td></tr></table></figure>
<p>上面的宏隐藏了模块的入口和出口函数，并注册了usb_mouse_driver接口驱动，usb_mouse_driver初始化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct usb_driver usb_mouse_driver = &#123;</span><br><span class="line">	.name		= &quot;usbmouse&quot;,</span><br><span class="line">	.probe		= usb_mouse_probe,</span><br><span class="line">	.disconnect	= usb_mouse_disconnect,</span><br><span class="line">	.id_table	= usb_mouse_id_table,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注册函数usb_register_driver在前面已经分析过，当usb总线match函数通过usb_mouse_driver的id_table成员匹配接口信息成功后，最终会调用到usb_mouse_driver的probe函数，即usb_mouse_probe。</p>
<h4 id="usbmouse的probe函数"><a href="#usbmouse的probe函数" class="headerlink" title="usbmouse的probe函数"></a>usbmouse的probe函数</h4><p>在usb_mouse_probe函数中首先获取接口描述和端点描述，并根据usb鼠标的特性判断设备是否有效，usb接口只能有一个端点，并且该端点类型必须是中断输入端点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface = intf-&gt;cur_altsetting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (interface-&gt;desc.bNumEndpoints != <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">endpoint = &amp;interface-&gt;endpoint[<span class="number">0</span>].desc;</span><br><span class="line"><span class="keyword">if</span> (!usb_endpoint_is_int_in(endpoint))</span><br><span class="line">	<span class="keyword">return</span> -ENODEV;</span><br></pre></td></tr></table></figure>
<p>然后是设置数据传输管道，计算传输长度，并申请缓冲。（只分析usb相关部分，忽略输入子系统相关代码）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pipe = usb_rcvintpipe(dev, endpoint-&gt;bEndpointAddress);</span><br><span class="line">maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mouse-&gt;data = usb_alloc_coherent(dev, <span class="number">8</span>, GFP_ATOMIC, &amp;mouse-&gt;data_dma);</span><br></pre></td></tr></table></figure>
<p>然后申请urb，并将上面的参数设置到urb中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mouse-&gt;irq = usb_alloc_urb(<span class="number">0</span>, GFP_KERNEL);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usb_fill_int_urb(mouse-&gt;irq, dev, pipe, mouse-&gt;data,</span><br><span class="line">			 (maxp &gt; <span class="number">8</span> ? <span class="number">8</span> : maxp),</span><br><span class="line">			 usb_mouse_irq, mouse, endpoint-&gt;bInterval);</span><br></pre></td></tr></table></figure>
<p>上面的代码在调用usb_fill_int_urb时传入了中断回调函数usb_mouse_irq，该中断回调是usb主设备不停的查询从设备，有数据则调用该回调函数进行处理。那urb是如何使用的？答案在usb_mouse_open函数里面，在usb_mouse_open函数中调用usb_submit_urb函数提交urb到usb子系统核心。由此可知，usb的数据传输都是通过urb完成的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">usb_mouse_open</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_mouse</span> *<span class="title">mouse</span> = <span class="title">input_get_drvdata</span>(<span class="title">dev</span>);</span></span><br><span class="line"></span><br><span class="line">	mouse-&gt;irq-&gt;dev = mouse-&gt;usbdev;</span><br><span class="line">	<span class="keyword">if</span> (usb_submit_urb(mouse-&gt;irq, GFP_KERNEL))</span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="usbmouse的usb-mouse-irq函数"><a href="#usbmouse的usb-mouse-irq函数" class="headerlink" title="usbmouse的usb_mouse_irq函数"></a>usbmouse的usb_mouse_irq函数</h4><p>前面说提交urb后从设备有数据回复就调用usb_mouse_irq函数，那么usb_mouse_irq函数又做了什么？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usb_mouse_irq</span><span class="params">(struct urb *urb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_mouse</span> *<span class="title">mouse</span> = <span class="title">urb</span>-&gt;<span class="title">context</span>;</span></span><br><span class="line">	<span class="keyword">signed</span> <span class="keyword">char</span> *data = mouse-&gt;data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">mouse</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (urb-&gt;status) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:			<span class="comment">/* success */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> -ECONNRESET:	<span class="comment">/* unlink */</span></span><br><span class="line">	<span class="keyword">case</span> -ENOENT:</span><br><span class="line">	<span class="keyword">case</span> -ESHUTDOWN:</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/* -EPIPE:  should clear the halt */</span></span><br><span class="line">	<span class="keyword">default</span>:		<span class="comment">/* error */</span></span><br><span class="line">		<span class="keyword">goto</span> resubmit;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	input_report_key(dev, BTN_LEFT,   data[<span class="number">0</span>] &amp; <span class="number">0x01</span>);</span><br><span class="line">	input_report_key(dev, BTN_RIGHT,  data[<span class="number">0</span>] &amp; <span class="number">0x02</span>);</span><br><span class="line">	input_report_key(dev, BTN_MIDDLE, data[<span class="number">0</span>] &amp; <span class="number">0x04</span>);</span><br><span class="line">	input_report_key(dev, BTN_SIDE,   data[<span class="number">0</span>] &amp; <span class="number">0x08</span>);</span><br><span class="line">	input_report_key(dev, BTN_EXTRA,  data[<span class="number">0</span>] &amp; <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">	input_report_rel(dev, REL_X,     data[<span class="number">1</span>]);</span><br><span class="line">	input_report_rel(dev, REL_Y,     data[<span class="number">2</span>]);</span><br><span class="line">	input_report_rel(dev, REL_WHEEL, data[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	input_sync(dev);</span><br><span class="line">resubmit:</span><br><span class="line">	status = usb_submit_urb (urb, GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		dev_err(&amp;mouse-&gt;usbdev-&gt;dev,</span><br><span class="line">			<span class="string">"can't resubmit intr, %s-%s/input0, status %d\n"</span>,</span><br><span class="line">			mouse-&gt;usbdev-&gt;bus-&gt;bus_name,</span><br><span class="line">			mouse-&gt;usbdev-&gt;devpath, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面代码可知，在usb_mouse_irq回调函数中处理了usb数据，在鼠标驱动中就是上报输入事件，完了重新提交urb，以进行下循环的urb请求。</p>
<h4 id="usb接口驱动总结"><a href="#usb接口驱动总结" class="headerlink" title="usb接口驱动总结"></a>usb接口驱动总结</h4><p>由以上usb鼠标驱动分析可知，一个usb设备（接口）驱动一般过程如下：</p>
<p>1.初始化usb_driver结构，初始化的时候设置probe函数，disconnect函数以及id_table</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">usb_mouse_driver</span> = &#123;</span></span><br><span class="line">	.name		= <span class="string">"usbmouse"</span>,</span><br><span class="line">	.probe		= usb_mouse_probe,</span><br><span class="line">	.disconnect	= usb_mouse_disconnect,</span><br><span class="line">	.id_table	= usb_mouse_id_table,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.在id_table中指定该驱动适合的usb设备，可根据usb的厂家ID和产品ID匹配，也可根据接口的Class匹配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> <span class="title">usb_mouse_id_table</span> [] = &#123;</span></span><br><span class="line">	&#123; USB_INTERFACE_INFO(USB_INTERFACE_INFO, USB_INTERFACE_SUBCLASS_BOOT,</span><br><span class="line">		USB_INTERFACE_PROTOCOL_MOUSE) &#125;,</span><br><span class="line">	&#123; &#125;	<span class="comment">/* Terminating entry */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码通过接口信息通过USB_INTERFACE_INFO宏匹配设备，表示匹配符合类为USB_INTERFACE_INFO，子类为USB_INTERFACE_SUBCLASS_BOOT，协议为USB_INTERFACE_PROTOCOL_MOUSE的所有设备，由此可见usb鼠标是一个比较通用的驱动。</p>
<p>也可通过宏USB_DEVICE指定通过设备的厂家ID和产品ID来匹配，比如以下id_table表示匹配厂家id为0x1234，产品ID为0x5678的设备：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static struct usb_device_id usb_mouse_id_table [] = &#123;</span><br><span class="line">	&#123; USB_DEVICE(0x1234, 0x5678) &#125;,</span><br><span class="line">	&#123; &#125;	/* Terminating entry */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3.实现probe和disconnect函数，disconnect函数主要做释放probe函数中申请的资源的工作。在probe中直接获取设备的描述信息，根据描述信息的相关参数申请并设置urb，然后实现urb的回调函数。其中比较重要且通用的接口使用如下：</p>
<p>申请buffer：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mouse-&gt;data = usb_alloc_coherent(dev, <span class="number">8</span>, GFP_ATOMIC, &amp;mouse-&gt;data_dma);</span><br><span class="line">	<span class="keyword">if</span> (!mouse-&gt;data)</span><br><span class="line">		<span class="keyword">goto</span> fail1;</span><br></pre></td></tr></table></figure>
<p>申请urb：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mouse-&gt;irq = usb_alloc_urb(<span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!mouse-&gt;irq)</span><br><span class="line">		<span class="keyword">goto</span> fail2;</span><br></pre></td></tr></table></figure>
<p>设置urb：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usb_fill_int_urb(mouse-&gt;irq, dev, pipe, mouse-&gt;data,</span><br><span class="line">			 (maxp &gt; <span class="number">8</span> ? <span class="number">8</span> : maxp),</span><br><span class="line">			 usb_mouse_irq, mouse, endpoint-&gt;bInterval);</span><br></pre></td></tr></table></figure>
<p>提交urb：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (usb_submit_urb(mouse-&gt;irq, GFP_KERNEL))</span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br></pre></td></tr></table></figure>
<p>在设置urb的时候还有两个重要的参数分别如下设置</p>
<p>获取管道：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipe = usb_rcvintpipe(dev, endpoint-&gt;bEndpointAddress);</span><br></pre></td></tr></table></figure>
<p>获取管道最大传输值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/Linux/">Linux</a><a href="/tags/kernel/">kernel</a><a href="/tags/usb/">usb</a></div><div class="post-nav"><a class="pre" href="/2019/07/28/hello-world/">Hello World</a><a class="next" href="/2019/06/09/Linux内核initcall过程/">Linux内核initcall过程</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  id: window.location.pathname.substring(1,window.location.pathname.length),
  owner: 'geekchenxd',
  repo: 'geekchenxd.github.io',
  oauth: {
    client_id: '00f3259791ebc5b5d412',
    client_secret: 'd88056bc0050337d5767e26f8d228f526ed7687d',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://www.chenxd.xyz"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel/">Kernel</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/qemu/">qemu</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Debug/" style="font-size: 15px;">Debug</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/subsystem/" style="font-size: 15px;">subsystem</a> <a href="/tags/initcall/" style="font-size: 15px;">initcall</a> <a href="/tags/notification/" style="font-size: 15px;">notification</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/watchdog/" style="font-size: 15px;">watchdog</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/arm/" style="font-size: 15px;">arm</a> <a href="/tags/dtb/" style="font-size: 15px;">dtb</a> <a href="/tags/dts/" style="font-size: 15px;">dts</a> <a href="/tags/file-system/" style="font-size: 15px;">file_system</a> <a href="/tags/Interrupt/" style="font-size: 15px;">Interrupt</a> <a href="/tags/usb/" style="font-size: 15px;">usb</a> <a href="/tags/device-driver/" style="font-size: 15px;">device driver</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/05/Linux内核调试之KGDB/">Linux内核调试之KGDB</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/Qemu虚拟Arm开发板/">Qemu虚拟Arm开发板</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/Linux内核通知链/">Linux内核通知链</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/Linux内核设备驱动模型/">Linux内核设备驱动模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/26/ARM-LINUX中断系统/">ARM-LINUX中断系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/25/Linux内核之看门狗子系统/">Linux内核之看门狗子系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/24/Linux内核之虚拟文件系统/">Linux内核之虚拟文件系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/28/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/09/Linux内核usb子系统/">Linux内核usb子系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/09/Linux内核initcall过程/">Linux内核initcall过程</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.github.com" title="github" target="_blank">github</a><ul></ul><a href="http://www.kernel.org" title="linux kernel" target="_blank">linux kernel</a><ul></ul><a href="http://www.combatpress.com/" title="Combat Press" target="_blank">Combat Press</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Evil Code.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>